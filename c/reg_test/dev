#!/bin/sh

# ================================================================
# This is similar to reg_test/run except that this one is only ever run
# manually, not automatically as part of the build. It can be used to iterate on
# as-yet-unreleased features (in particular, features whose definition isn't
# finalized) without breaking the build.
# ================================================================
set -e

ourdir=`dirname $0`
srcdir=$ourdir/../..
pwd=`pwd`

try1=$pwd/../mlr    # For autoconf builds, in-tree or out-of-tree
try2=$srcdir/c/mlr  # For non-autoconf builds
if [ -x "$try1" ]; then
  path_to_mlr=$try1
elif [ -x "$try2" ]; then
  path_to_mlr=$try2
else
  echo "$0: Could not find path to mlr executable." 1>&2
  echo "Try 1: $try1" 1>&2
  echo "Try 2: $try2" 1>&2
  exit 1
fi
do_diff="true"

for arg; do
  if [ "$1" = "--valgrind" ]; then
    # Leak-check the test suite. Needs 'make mlrg' first.
    # ../tools/clean-valg can be used to filter the output.
    path_to_mlr="valgrind --leak-check=full ${path_to_mlr}g"
  elif [ "$1" = "--nodiff" ]; then
    do_diff="false"
  fi
done
echo Using mlr executable $path_to_mlr

indir=$ourdir/input
expdir=$ourdir/expected
outdir=$pwd/output
outfile=$outdir/out-dev
expfile=$expdir/out-dev
mkdir -p $outdir

rm -f $outfile
touch $outfile
echo

num_passed=0

announce() {
	echo >> $outfile
	echo "================================================================" >> $outfile
	echo "$@" >> $outfile
	echo >> $outfile
}

mention() {
	echo >> $outfile
	echo ---------------------------------------------------------------- "$@" >> $outfile
}

run_mlr() {
  # Use just "mlr" for info messages
	echo mlr "$@"
	echo mlr "$@" >> $outfile
  # Use path to mlr for invoking the command
	$path_to_mlr "$@" >> $outfile
	echo >> $outfile
	# since set -e
	num_passed=`expr $num_passed + 1`
}

# ================================================================
announce GRAMMAR REORG

run_mlr -n put -v '$["x"]=3'
run_mlr -n put -v '@["x"]=3'
run_mlr -n put -v '$[$y]=$y'
run_mlr -n put -v '@[@y]=@y'

run_mlr -n put -v '@x=2; @x["y"]=3; @x["y"][$z]=4'
run_mlr -n put -v '@["x"]=2; @["x"]["y"]=3; @["x"]["y"][$z]=4'
run_mlr --from $indir/abixy put -q -v '@a=2; @b["y"]=3; @c["y"][$a]=4; emitp all'
run_mlr --from $indir/abixy put -q -v '@a=2; @b["y"]=3; @c["y"][$a]=4; emitp all'
run_mlr --from $indir/abixy put -q -v '@["a"]=2; @["b"]["y"]=3; @["c"]["y"][$a]=4; emitp all'

echo x=1|mlr put '$x=$x+1; for (k,v in $*) { $[v] = typeof(v)}'
# x=2,2=MT_INT

echo x=1|mlr put 'for (k,v in $*) { $[v] = typeof(v)}'
# x=1,1=MT_STRING

run_mlr put -v '@s = NR; $t = typeof(@s); $u= typeof(@["s"]); emitp all' /Users/kerl/pub_http_internet/miller/c/reg_test/input/abixy

run_mlr --opprint put -v '@s = NR; $t = @s; $u=@["s"]' /Users/kerl/pub_http_internet/miller/c/reg_test/input/abixy

run_mlr put -v '@t["u"] = NR; $tu = @["t"]["u"]; emitp all' $indir/abixy # xxx broken: second statement doesn't parse


run_mlr put -v '@["t"]["u"] = $y; emitp all' $indir/abixy

run_mlr --from $indir/abixy put -S -v '$sum = 0; for(k,v in $*) {if (k =~ "^[xy]$") {$sum += $[k]} }' # xxx broken this should autoconvert to numeric unless -S:

run_mlr --from $indir/abixy put -S -v '$sum = 0; for(k,v in $*) {if (k =~ "^[xy]$") {$sum += float($[k])} }' # xxx broken why sum == error ?

run_mlr --from $indir/abixy put -S -v '$sum = 0; for(k,v in $*) {if (k >= "i") {$sum += $[k]} }' # xxx broken why sum == error ?
run_mlr --from $indir/abixy put -S -v '$sum = 0; for(k,v in $*) {if (k >= "i") {$sum += $[k]} }' # xxx broken why sum == error ?

run_mlr -n put -v '
  $a = @s;
  $b = @t[1];
  $c = @u[1][2];
  $d = @v[1][2][3];
  $e = @["s"];
  $f = @["t"][1];
  $g = @["u"][1][2];
  $h = @["v"][1][2][3];
  '

# ================================================================
cat $outfile

if [ "$do_diff" = "true" ]; then
  echo
  diff -I '^mlr ' -C5 $expfile $outfile
  echo diff OK # since set -e
  echo ALL REGRESSION TESTS PASSED
  echo Tests completed: $num_passed
fi
