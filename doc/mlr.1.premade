'\" t
.\"     Title: mlr
.\"    Author: [see the "AUTHOR" section]
.\" Generator: ./mkman.rb
.\"      Date: 2015-11-16
.\"    Manual: \ \&
.\"    Source: \ \&
.\"  Language: English
.\"
.TH "MILLER" "1" "2015-11-16" "\ \&" "\ \&"
.\" -----------------------------------------------------------------
.\" * Portability definitions
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq (aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.SH "NAME"
.sp
Miller is like sed, awk, cut, join, and sort for name-indexed data such as CSV.
.SH "SYNOPSIS"
.sp
Usage: mlr [I/O options] {verb} [verb-dependent options ...] {zero or more file names}

.SH "DESCRIPTION"
.sp
Miller operates on key-value-pair data while the familiar Unix tools operate
on integer-indexed fields: if the natural data structure for the latter is the
array, then Miller's natural data structure is the insertion-ordered hash map.
This encompasses a variety of data formats, including but not limited to the
familiar CSV.  (Miller can handle positionally-indexed data as a special
case.)
.SH "EXAMPLES"
.sp

.SS "COMMAND-LINE SYNTAX"
.if n \{\
.RS 0
.\}
.nf
mlr --csv --rs lf --fs tab cut -f hostname,uptime file1.tsv file2.tsv
mlr --csv cut -f hostname,uptime mydata.csv
mlr --csv filter '$status != "down" && $upsec >= 10000' *.csv
mlr --nidx put '$sum = $7 + 2.1*$8' *.dat
grep -v '^#' /etc/group | mlr --ifs : --nidx --opprint label group,pass,gid,member then sort -f group
mlr join -j account_id -f accounts.dat then group-by account_name balances.dat
mlr put '$attr = sub($attr, "([0-9]+)_([0-9]+)_.*", "\e1:\e2")' data/*
mlr stats1 -a min,mean,max,p10,p50,p90 -f flag,u,v data/*
mlr stats2 -a linreg-pca -f u,v -g shape data/*
.fi
.if n \{\
.RE
.SS "DATA FORMATS"
.if n \{\
.RS 0
.\}
.nf
  DKVP: delimited key-value pairs (Miller default format)
  +---------------------+
  | apple=1,bat=2,cog=3 |  Record 1: "apple" => "1", "bat" => "2", "cog" => "3"
  | dish=7,egg=8,flint  |  Record 2: "dish" => "7", "egg" => "8", "3" => "flint"
  +---------------------+
  
  NIDX: implicitly numerically indexed (Unix-toolkit style)
  +---------------------+
  | the quick brown     | Record 1: "1" => "the", "2" => "quick", "3" => "brown"
  | fox jumped          | Record 2: "1" => "fox", "2" => "jumped"
  +---------------------+
  
  CSV/CSV-lite: comma-separated values with separate header line
  +---------------------+
  | apple,bat,cog       |
  | 1,2,3               | Record 1: "apple => "1", "bat" => "2", "cog" => "3"
  | 4,5,6               | Record 2: "apple" => "4", "bat" => "5", "cog" => "6"
  +---------------------+
  
  PPRINT: pretty-printed tabular
  +---------------------+
  | apple bat cog       |
  | 1     2   3         | Record 1: "apple => "1", "bat" => "2", "cog" => "3"
  | 4     5   6         | Record 2: "apple" => "4", "bat" => "5", "cog" => "6"
  +---------------------+
  
  XTAB: pretty-printed transposed tabular
  +---------------------+
  | apple 1             | Record 1: "apple" => "1", "bat" => "2", "cog" => "3"
  | bat   2             |
  | cog   3             |
  |                     |
  | dish 7              | Record 2: "dish" => "7", "egg" => "8"
  | egg  8              |
  +---------------------+
.fi
.if n \{\
.RE
.SH "OPTIONS"
.sp
In the following option flags, the version with "i" designates the input
stream, "o" the output stream, and the version without prefix sets the option
for both input and output stream. For example: --irs sets the input record
separator, --ors the output record separator, and --rs sets both the input and
output separator to the given value.
.SS "HELP OPTIONS"
.if n \{\
.RS 0
.\}
.nf
  -h or --help Show this message.
  --version              Show the software version.
  {verb name} --help     Show verb-specific help.
  --list-all-verbs or -l List only verb names.
  --help-all-verbs       Show help on all verbs.
.fi
.if n \{\
.RE
.SS "VERB LIST"
.if n \{\
.RS 0
.\}
.nf
 bar cat check count-distinct cut filter grep group-by group-like having-fields
 head histogram join label put regularize rename reorder sample sec2gmt sort
 stats1 stats2 step tac tail top uniq
.fi
.if n \{\
.RE
.SS "FUNCTION LIST"
.if n \{\
.RS 0
.\}
.nf
 abs acos acosh asin asinh atan atan2 atanh cbrt ceil cos cosh erf erfc exp
 expm1 floor invqnorm log log10 log1p logifit madd msub mmul mexp max min pow
 qnorm round roundm sgn sin sinh sqrt tan tanh urand urandint + + - - * / // %
 ** | ^ & ~ << >> =~ !=~ == != > >= < <= && || ^^ ! strlen sub gsub tolower
 toupper . boolean float int string hexfmt fmtnum systime sec2gmt gmt2sec
 sec2hms sec2dhms hms2sec dhms2sec fsec2hms fsec2dhms hms2fsec dhms2fsec
Please use "mlr --help-function {function name}" for function-specific help.
Please use "mlr --help-all-functions" or "mlr -f" for help on all functions.
.fi
.if n \{\
.RE
.SS "I/O FORMATTING"
.if n \{\
.RS 0
.\}
.nf
  --idkvp   --odkvp   --dkvp            Delimited key-value pairs, e.g "a=1,b=2"
                                        (default)
  --inidx   --onidx   --nidx            Implicitly-integer-indexed fields
                                        (Unix-toolkit style)
  --icsv    --ocsv    --csv             Comma-separated value (or tab-separated
                                        with --fs tab, etc.)
  --ipprint --opprint --pprint --right  Pretty-printed tabular (produces no
                                        output until all input is in)
  --ixtab   --oxtab   --xtab --xvright  Pretty-printed vertical-tabular
  The --right option right-justifies all fields for PPRINT output format.
  The --xvright option right-justifies values for XTAB format.
  -p is a keystroke-saver for --nidx --fs space --repifs
  Examples: --csv for CSV-formatted input and output; --idkvp --opprint for
  DKVP-formatted input and pretty-printed output.
.fi
.if n \{\
.RE
.SS "SEPARATORS"
.if n \{\
.RS 0
.\}
.nf
  --rs     --irs     --ors              Record separators, e.g. 'lf' or '\er\en'
  --fs     --ifs     --ofs  --repifs    Field separators, e.g. comma
  --ps     --ips     --ops              Pair separators, e.g. equals sign
  Notes:
  * IPS/OPS are only used for DKVP and XTAB formats, since only in these formats
    do key-value pairs appear juxtaposed.
  * IRS/ORS are ignored for XTAB format. Nominally IFS and OFS are newlines;
    XTAB records are separated by two or more consecutive IFS/OFS -- i.e.
    a blank line.
  * OFS must be single-character for PPRINT format. This is because it is used
    with repetition for alignment; multi-character separators would make
    alignment impossible.
  * OPS may be multi-character for XTAB format, in which case alignment is
    disabled.
  * DKVP, NIDX, CSVLITE, PPRINT, and XTAB formats are intended to handle
    platform-native text data. In particular, this means LF line-terminators
    by default on Linux/OSX. You can use "--dkvp --rs crlf" for
    CRLF-terminated DKVP files, and so on.
  * CSV is intended to handle RFC-4180-compliant data. In particular, this means
    it uses CRLF line-terminators by default. You can use "--csv --rs lf" for
    Linux-native CSV files.
  * You can specify separators in any of the following ways, shown by example:
    - Type them out, quoting as necessary for shell escapes, e.g.
      "--fs '|' --ips :"
    - C-style escape sequences, e.g. "--rs '\er\en' --fs '\et'".
    - To avoid backslashing, you can use any of the following names:
      cr crcr newline lf lflf crlf crlfcrlf tab space comma pipe slash colon semicolon equals
  * Default separators by format:
      File format  RS       FS       PS
      dkvp         \en       ,        =
      nidx         \en       space    (N/A)
      csv          \er\en     ,        (N/A)
      csvlite      \en       ,        (N/A)
      pprint       \en       space    (N/A)
      xtab         (N/A)    \en       space
.fi
.if n \{\
.RE
.SS "CSV-SPECIFIC OPTIONS"
.if n \{\
.RS 0
.\}
.nf
  --implicit-csv-header Use 1,2,3,... as field labels, rather than from line 1
                     of input files. Tip: combine with "label" to recreate
                     missing headers.
.fi
.if n \{\
.RE
.SS "DOUBLE-QUOTING FOR CSV/CSVLITE OUTPUT"
.if n \{\
.RS 0
.\}
.nf
  --quote-all        Wrap all fields in double quotes
  --quote-none       Do not wrap any fields in double quotes, even if they have 
                     OFS or ORS in them
  --quote-minimal    Wrap fields in double quotes only if they have OFS or ORS
                     in them (default)
  --quote-numeric    Wrap fields in double quotes only if they have numbers
                     in them
.fi
.if n \{\
.RE
.SS "NUMERICAL FORMATTING"
.if n \{\
.RS 0
.\}
.nf
  --ofmt {format}    E.g. %.18lf, %.0lf. Please use sprintf-style codes for
                     double-precision. Applies to verbs which compute new
                     values, e.g. put, stats1, stats2. See also the fmtnum
                     function within mlr put (mlr --help-all-functions).
.fi
.if n \{\
.RE
.SS "OTHER OPTIONS"
.if n \{\
.RS 0
.\}
.nf
  --seed {n} with n of the form 12345678 or 0xcafefeed. For put/filter
                     urand()/urandint().
.fi
.if n \{\
.RE
.SS "THEN-CHAINING"
.if n \{\
.RS 0
.\}
.nf
Output of one verb may be chained as input to another using "then", e.g.
  mlr stats1 -a min,mean,max -f flag,u,v -g color then sort -f color
.fi
.if n \{\
.RE
.SH "VERBS"
.sp

.SS "bar"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr bar [options]
Replaces a numeric field with a number of asterisks, allowing for cheesy bar plots.
These align best with --opprint or --oxtab output format.
Options:
-f   {a,b,c}      Field names to convert to bars.
-c   {character}  Fill character: default '*'.
-x   {character}  Out-of-bounds character: default '#'.
-b   {character}  Blank character: default '.'.
--lo {lo}         Lower-limit value for min-width bar: default '0.000000'.
--hi {hi}         Upper-limit value for max-width bar: default '100.000000'.
-w   {n}          Bar-field width: default '40'.
.fi
.if n \{\
.RE
.SS "cat"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr cat [options]
Passes input records directly to output. Most useful for format conversion.
Options:
-n        Prepend field "n" to each record with record-counter starting at 1
-N {name} Prepend field {name} to each record with record-counter starting at 1
.fi
.if n \{\
.RE
.SS "check"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr check
Consumes records without printing any output.
Useful for doing a well-formatted check on input data.
.fi
.if n \{\
.RE
.SS "count-distinct"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr count-distinct [options]
-f {a,b,c}   Field names for distinct count.
Prints number of records having distinct values for specified field names.
Same as uniq -c.
.fi
.if n \{\
.RE
.SS "cut"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr cut [options]
Passes through input records with specified fields included/excluded.
-f {a,b,c}       Field names to include for cut.
-o               Retain fields in the order specified here in the argument list.
                 Default is to retain them in the order found in the input data.
-x|--complement  Exclude, rather than include, field names specified by -f.
-r               Treat field names as regular expressions. "ab", "a.*b" will
                 match any field name containing the substring "ab" or matching
                 "a.*b", respectively; anchors of the form "^ab$", "^a.*b$" may
                 be used. The -o flag is ignored when -r is present.
Examples:
  mlr cut -f hostname,status
  mlr cut -x -f hostname,status
  mlr cut -r -f '^status$,sda[0-9]'
  mlr cut -r -f '^status$,"sda[0-9]"'
  mlr cut -r -f '^status$,"sda[0-9]"i' (this is case-insensitive)
.fi
.if n \{\
.RE
.SS "filter"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr filter [-v] [-x] [-s|-f] {expression}
Prints records for which {expression} evaluates to true.
-x: Prints records for which {expression} evaluates to false.
-v: First prints the AST (abstract syntax tree) for the expression, which gives
    full transparency on the precedence and associativity rules of Miller's
    grammar.
-s: Keeps field values, or literals in the expression, as strings with no type 
    inference to int or float.
-f: Keeps field values, or literals in the expression, as strings or floats
    with no inference to int.
Please use a dollar sign for field names and double-quotes for string
literals. Miller built-in variables are NF NR FNR FILENUM FILENAME PI E.
Examples:
  mlr filter 'log10($count) > 4.0'
  mlr filter 'FNR == 2          (second record in each file)'
  mlr filter 'urand() < 0.001'  (subsampling)
  mlr filter '$color != "blue" && $value > 4.2'
  mlr filter '($x<.5 && $y<.5) || ($x>.5 && $y>.5)'
  mlr filter '($name =~ "^sys.*east$") || ($name =~ "^dev.[0-9]+"i)'
Please see http://johnkerl.org/miller/doc/reference.html for more information
including function list. Or "mlr -f". Please also also "mlr grep" which is
useful when you don't yet know which field name(s) you're looking for.
.fi
.if n \{\
.RE
.SS "grep"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr grep [options] {regular expression}
Passes through records which match {regex}.
Options:
-i    Use case-insensitive search.
-v    Invert: pass through records which do not match the regex.
Note that "mlr filter" is more powerful, but requires you to know field names.
By contrast, "mlr grep" allows you to regex-match the entire record. It does
this by formatting each record in memory as DKVP, using command-line-specified
ORS/OFS/OPS, and matching the resulting line against the regex specified
here. In particular, the regex is not applied to the input stream: if you
have CSV with header line "x,y,z" and data line "1,2,3" then the regex will
be matched, not against either of these lines, but against the DKVP line
"x=1,y=2,z=3".  Furthermore, not all the options to system grep are supported,
and this command is intended to be merely a keystroke-saver. To get all the
features of system grep, you can do
  "mlr --odkvp ... | grep ... | mlr --idkvp ..."
.fi
.if n \{\
.RE
.SS "group-by"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr group-by {comma-separated field names}
Outputs records in batches having identical values at specified field names.
.fi
.if n \{\
.RE
.SS "group-like"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr group-like
Outputs records in batches having identical field names.
.fi
.if n \{\
.RE
.SS "having-fields"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr having-fields [options]
Conditionally passes through records depending on each record's field names.
Options:
  --at-least      {comma-separated names}
  --which-are     {comma-separated names}
  --at-most       {comma-separated names}
  --all-matching  {regular expression}
  --any-matching  {regular expression}
  --none-matching {regular expression}
Examples:
  mlr having-fields --which-are amount,status,owner
  mlr having-fields --any-matching 'sda[0-9]'
  mlr having-fields --any-matching '"sda[0-9]"'
  mlr having-fields --any-matching '"sda[0-9]"i' (this is case-insensitive)
.fi
.if n \{\
.RE
.SS "head"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr head [options]
-n {count}    Head count to print; default 10
-g {a,b,c}    Optional group-by-field names for head counts
Passes through the first n records, optionally by category.
.fi
.if n \{\
.RE
.SS "histogram"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr histogram [options]
-f {a,b,c}    Value-field names for histogram counts
--lo {lo}     Histogram low value
--hi {hi}     Histogram high value
--nbins {n}   Number of histogram bins
Just a histogram. Input values < lo or > hi are not counted.
.fi
.if n \{\
.RE
.SS "join"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr join [options]
Joins records from specified left file name with records from all file names
at the end of the Miller argument list.
Functionality is essentially the same as the system "join" command, but for
record streams.
Options:
  -f {left file name}
  -j {a,b,c}   Comma-separated join-field names for output
  -l {a,b,c}   Comma-separated join-field names for left input file;
               defaults to -j values if omitted.
  -r {a,b,c}   Comma-separated join-field names for right input file(s);
               defaults to -j values if omitted.
  --lp {text}  Additional prefix for non-join output field names from
               the left file
  --rp {text}  Additional prefix for non-join output field names from
               the right file(s)
  --np         Do not emit paired records
  --ul         Emit unpaired records from the left file
  --ur         Emit unpaired records from the right file(s)
  -u           Enable unsorted input. In this case, the entire left file will
               be loaded into memory. Without -u, records must be sorted
               lexically by their join-field names, else not all records will
               be paired.
File-format options default to those for the right file names on the Miller
argument list, but may be overridden for the left file as follows. Please see
the main "mlr --help" for more information on syntax for these arguments.
  -i {one of csv,dkvp,nidx,pprint,xtab}
  --irs {record-separator character}
  --ifs {field-separator character}
  --ips {pair-separator character}
  --repifs
  --repips
  --use-mmap
  --no-mmap
Please see http://johnkerl.org/miller/doc/reference.html for more information
including examples.
.fi
.if n \{\
.RE
.SS "label"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr label {new1,new2,new3,...}
Given n comma-separated names, renames the first n fields of each record to
have the respective name. (Fields past the nth are left with their original
names.) Particularly useful with --inidx or --implicit-csv-header, to give
useful names to otherwise integer-indexed fields.
Examples:
  "echo 'a b c d' | mlr --inidx --odkvp cat"       gives "1=a,2=b,3=c,4=d"
  "echo 'a b c d' | mlr --inidx --odkvp label s,t" gives "s=a,t=b,3=c,4=d"
.fi
.if n \{\
.RE
.SS "put"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr put [-v] [-s|-f] {expression}
Adds/updates specified field(s).
-v: First prints the AST (abstract syntax tree) for the expression, which gives
    full transparency on the precedence and associativity rules of Miller's
    grammar.
-s: Keeps field values, or literals in the expression, as strings with no type 
    inference to int or float.
-f: Keeps field values, or literals in the expression, as strings or floats
    with no inference to int.
Please use a dollar sign for field names and double-quotes for string
literals. Miller built-in variables are NF NR FNR FILENUM FILENAME PI E.
Multiple assignments may be separated with a semicolon.
Examples:
  mlr put '$y = log10($x); $z = sqrt($y)'
  mlr put '$filename = FILENAME'
  mlr put '$colored_shape = $color . "_" . $shape'
  mlr put '$y = cos($theta); $z = atan2($y, $x)'
  mlr put '$name = sub($name, "http.*com"i, "")'
Please see http://johnkerl.org/miller/doc/reference.html for more information
including function list.
.fi
.if n \{\
.RE
.SS "regularize"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr regularize
For records seen earlier in the data stream with same field names in
a different order, outputs them with field names in the previously
encountered order.
Example: input records a=1,c=2,b=3, then e=4,d=5, then c=7,a=6,b=8
output as              a=1,c=2,b=3, then e=4,d=5, then a=6,c=7,b=8
.fi
.if n \{\
.RE
.SS "rename"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr rename [options] {old1,new1,old2,new2,...}
Renames specified fields.
Options:
-r         Treat old field  names as regular expressions. "ab", "a.*b"
           will match any field name containing the substring "ab" or
           matching "a.*b", respectively; anchors of the form "^ab$",
           "^a.*b$" may be used. New field names may be plain strings,
           or may contain capture groups of the form "\e1" through
           "\e9". Wrapping the regex in double quotes is optional, but
           is required if you wish to follow it with 'i' to indicate
           case-insensitivity.
-g         Do global replacement within each field name rather than
           first-match replacement.
Examples:
mlr rename -r 'Date_[0-9]+,Date,'  Rename all such fields to be "Date"
mlr rename -r '"Date_[0-9]+",Date' Same
mlr rename -r 'Date_([0-9]+).*,\e1' Rename all such fields to be of the form 20151015
mlr rename -r '"name"i,Name'       Rename "name", "Name", "NAME", etc. to "Name"
.fi
.if n \{\
.RE
.SS "reorder"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr reorder [options]
-f {a,b,c}   Field names to reorder.
-e           Put specified field names at record end: default is to put
             them at record start.
Examples:
mlr reorder    -f a,b sends input record "d=4,b=2,a=1,c=3" to "a=1,b=2,d=4,c=3".
mlr reorder -e -f a,b sends input record "d=4,b=2,a=1,c=3" to "d=4,c=3,a=1,b=2".
.fi
.if n \{\
.RE
.SS "sample"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr sample [options]
Reservoir sampling, optionally by category.
-k {count}    Required: number of records to output, total, or by group if using -g.
-g {a,b,c}    Optional: group-by-field names for samples.
.fi
.if n \{\
.RE
.SS "sec2gmt"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr sec2gmt {comma-separated list of field names}
Replaces a numeric field representing seconds since the epoch with the
corresponding GMT timestamp. This is nothing more than a keystroke-saver for
the sec2gmt function:
  mlr sec2gmt time1,time2
is the same as
  mlr put '$time1=sec2gmt($time1);$time2=sec2gmt($time2)'
.fi
.if n \{\
.RE
.SS "sort"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr sort {flags}
Flags:
  -f  {comma-separated field names}  Lexical ascending
  -n  {comma-separated field names}  Numerical ascending; nulls sort last
  -nf {comma-separated field names}  Numerical ascending; nulls sort last
  -r  {comma-separated field names}  Lexical descending
  -nr {comma-separated field names}  Numerical descending; nulls sort first
Sorts records primarily by the first specified field, secondarily by the second
field, and so on.  Any records not having all specified sort keys will appear
at the end of the output, in the order they were encountered, regardless of the
specified sort order.
Example:
  mlr sort -f a,b -nr x,y,z
which is the same as:
  mlr sort -f a -f b -nr x -nr y -nr z
.fi
.if n \{\
.RE
.SS "stats1"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr stats1 [options]
Options:
-a {sum,count,...}  Names of accumulators: p10 p25.2 p50 p98 p100 etc. and/or
                    one or more of:
  count   Count instances of fields
  mode    Find most-frequently-occurring values for fields; first-found wins tie
  sum     Compute sums of specified fields
  mean    Compute averages (sample means) of specified fields
  stddev  Compute sample standard deviation of specified fields
  var     Compute sample variance of specified fields
  meaneb  Estimate error bars for averages (assuming no sample autocorrelation)
  skewness Compute sample skewness of specified fields
  kurtosis Compute sample kurtosis of specified fields
  min     Compute minimum values of specified fields
  max     Compute maximum values of specified fields
-f {a,b,c}  Value-field names on which to compute statistics
-g {d,e,f}  Optional group-by-field names
-s          Print iterative stats. Useful in tail -f contexts (in which
            case please avoid pprint-format output since end of input
            stream will never be seen).
Example: mlr stats1 -a min,p10,p50,p90,max -f value -g size,shape
Example: mlr stats1 -a count,mode -f size
Example: mlr stats1 -a count,mode -f size -g shape
Notes:
* p50 is a synonym for median.
* min and max output the same results as p0 and p100, respectively, but use
  less memory.
* count and mode allow text input; the rest require numeric input.
  In particular, 1 and 1.0 are distinct text for count and mode.
* When there are mode ties, the first-encountered datum wins.
.fi
.if n \{\
.RE
.SS "stats2"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr stats2 [options]
-a {linreg-ols,corr,...}  Names of accumulators: one or more of:
  linreg-pca   Linear regression using principal component analysis
  linreg-ols   Linear regression using ordinary least squares
  r2           Quality metric for linreg-ols (linreg-pca emits its own)
  logireg      Logistic regression
  corr         Sample correlation
  cov          Sample covariance
  covx         Sample-covariance matrix
-f {a,b,c,d}   Value-field name-pairs on which to compute statistics.
               There must be an even number of names.
-g {e,f,g}     Optional group-by-field names.
-v             Print additional output for linreg-pca.
-s             Print iterative stats. Useful in tail -f contexts (in which
               case please avoid pprint-format output since end of input
               stream will never be seen).
--fit          Rather than printing regression parameters, applies them to
               the input data to compute new fit fields. All input records are
               held in memory until end of input stream. Has effect only for
               linreg-ols, linreg-pca, and logireg.
Only one of -s or --fit may be used.
Example: mlr stats2 -a linreg-pca -f x,y
Example: mlr stats2 -a linreg-ols,r2 -f x,y -g size,shape
Example: mlr stats2 -a corr -f x,y
.fi
.if n \{\
.RE
.SS "step"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr step [options]
-a {delta,rsum,...}   Names of steppers: comma-separated, one or more of:
  delta    Compute differences in field(s) between successive records
  ratio    Compute ratios in field(s) between successive records
  rsum     Compute running sums of field(s) between successive records
  counter  Count instances of field(s) between successive records
-f {a,b,c}            Value-field names on which to compute statistics
-g {d,e,f}            Optional group-by-field names
Computes values dependent on the previous record, optionally grouped
by category.
.fi
.if n \{\
.RE
.SS "tac"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr tac
Prints records in reverse order from the order in which they were encountered.
.fi
.if n \{\
.RE
.SS "tail"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr tail [options]
-n {count}    Tail count to print; default 10
-g {a,b,c}    Optional group-by-field names for tail counts
Passes through the last n records, optionally by category.
.fi
.if n \{\
.RE
.SS "top"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr top [options]
-f {a,b,c}    Value-field names for top counts.
-g {d,e,f}    Optional group-by-field names for top counts.
-n {count}    How many records to print per category; default 1.
-a            Print all fields for top-value records; default is
              to print only value and group-by fields. Requires a single
              value-field name only.
--min         Print top smallest values; default is top largest values.
Prints the n records with smallest/largest values at specified fields,
optionally by category.
.fi
.if n \{\
.RE
.SS "uniq"
.if n \{\
.RS 0
.\}
.nf
Usage: mlr uniq [options]
-g {d,e,f}    Group-by-field names for uniq counts
-c            Show repeat counts in addition to unique values
Prints distinct values for specified field names. With -c, same as
count-distinct.
.fi
.if n \{\
.RE
.SH "AUTHOR"
.sp
Miller is written by John Kerl <kerl.john.r@gmail.com>.
.sp
This manual page has been composed from Miller's help output by Eric MSP Veith <eveith@veith-m.de>.
.SH "SEE ALSO"
.sp
sed(1), awk(1), cut(1), join(1), sort(1), RFC 4180: Common Format and MIME Type for Comma-Separated Values (CSV) Files, the miller website http://johnkerl.org/miller/doc
