<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">

<!-- PAGE GENERATED FROM template.html and content-for-reference.html BY poki. -->
<!-- PLEASE MAKE CHANGES THERE AND THEN RE-RUN poki. -->
<head>
  <meta http-equiv="Content-type" content="text/html;charset=UTF-8"/>
  <meta name="description" content="Miller documentation"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/> <!-- mobile-friendly -->
  <meta name="keywords"
	content="John Kerl, Kerl, Miller, miller, mlr, OLAP, data analysis software, regression, correlation, variance, data tools, " />

  <title> Reference </title>
  <link rel="stylesheet" type="text/css" href="css/miller.css"/>
  <link rel="stylesheet" type="text/css" href="css/poki-callbacks.css"/>
</head>

<!-- ================================================================ -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-15651652-1");
pageTracker._trackPageview();
} catch(err) {}
</script>

<script type="text/javascript">
	function toggle(divName) {
		var eleDiv = document.getElementById(divName);
		if (eleDiv != null) {
			if (eleDiv.style.display == "block") {
				eleDiv.style.display = "none";
			} else {
				eleDiv.style.display = "block";
			}
		}
	}
</script>

<!--
The background image is from a screenshot of a Google search for "data analysis
tools", lightened and sepia-toned. Over this was placed a Mac Terminal app with
very light-grey font and translucent background, in which a few statistical
Miller commands were run with pretty-print-tabular output format.
-->
<body background="pix/sepia-overlay.jpg">

<!-- ================================================================ -->
<table width="100%">
<tr>

  <!-- navbar -->
  <td width="15%">
    <!--
    <img src="pix/mlr.jpg" />
    <img style="border-width:1px; color:black;" src="pix/mlr.jpg" />
    -->

    <div class="pokinav">
      <center><titleinbody>Miller</titleinbody></center>
      
<!-- PAGE LIST GENERATED FROM template.html BY poki -->
<br/>&bull;&nbsp;<a href="index.html">About Miller</a>
<br/>&bull;&nbsp;<a href="file-formats.html">File formats</a>
<br/>&bull;&nbsp;<a href="feature-comparison.html">Miller features in the context of the Unix toolkit</a>
<br/>&bull;&nbsp;<a href="record-heterogeneity.html">Record-heterogeneity</a>
<br/>&bull;&nbsp;<a href="reference.html"><b>Reference</b></a>
<br/>&bull;&nbsp;<a href="data-examples.html">Data examples</a>
<br/>&bull;&nbsp;<a href="cookbook.html">Cookbook</a>
<br/>&bull;&nbsp;<a href="faq.html">FAQ</a>
<br/>&bull;&nbsp;<a href="internationalization.html">Internationalization</a>
<br/>&bull;&nbsp;<a href="build.html">Installation, portability, dependencies, and testing</a>
<br/>&bull;&nbsp;<a href="performance.html">Performance</a>
<br/>&bull;&nbsp;<a href="whyc.html">Why C?</a>
<br/>&bull;&nbsp;<a href="etymology.html">Why call it Miller?</a>
<br/>&bull;&nbsp;<a href="originality.html">How original is Miller?</a>
<br/>&bull;&nbsp;<a href="to-do.html">Things to do</a>
<br/>&bull;&nbsp;<a href="release-docs.html">Documents by release</a>
<br/>&bull;&nbsp;<a href="contact.html">Contact information</a>
<br/>&bull;&nbsp;<a href="https://github.com/johnkerl/miller">GitHub repo</a>
      <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/>
      <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/>
      <br/> <br/> <br/> <br/> <br/> <br/>
    </div>
  </td>

  <!-- page body -->
  <td>
    <!--
      This is a visually gorgeous feature (here & in the CSS): it allows for
      independent scroll of the nav and body panels. In particular the nav
      stays on-screen as you scroll the body.

      However, two problems:

      (1) In Firefox & Chrome both I get janky end-of-body scrolls: there is
      more content but I can't scroll down to it unless I repeatedly retry the
      scrolldown. Which is weird.

      (2) Worse, only the first page renders in PDF (again, Firefox & Chrome).

      For now I'm disabling this separate-scroll feature. A frontender, I am
      not ... maybe someday I'll find a config which gets *all* the features
      I want; for now, it's a tradeoff.
    -->

    <!-- Implementation details: one bit is right here:

    div style="overflow-y:scroll;height:1500px"

    and the other bit is in css/poki-callbacks.css:

    .pokinav {
      display:        inline-block;
      background:     #e8d9bc;
      border:         1;
      box-shadow:     0px 0px 3px 3px #C9C9C9;
      margin:         10px;
      padding-top:    10px;
      padding-bottom: 10px;
      padding-left:   10px;
      padding-right:  10px;
      overflow-y:     scroll;  < - - - - - - here
      height: 1500px;
    }

    -->
    <div>
    <center> <titleinbody> Reference </titleinbody> </center>
    <p/>
    
<!-- BODY COPIED FROM content-for-reference.html BY poki -->
<div class="pokitoc">
<center><b>Contents:</b></center>
&bull;&nbsp;<a href="#Command_overview">Command overview</a><br/>
&bull;&nbsp;<a href="#On-line_help">On-line help</a><br/>
&bull;&nbsp;<a href="#Data_types">Data types</a><br/>
&bull;&nbsp;<a href="#Null_data">Null data</a><br/>
&bull;&nbsp;<a href="#I/O_options">I/O options</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Formats">Formats</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Compression">Compression</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Record/field/pair_separators">Record/field/pair separators</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Number_formatting">Number formatting</a><br/>
&bull;&nbsp;<a href="#Data_transformations">Data transformations</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#bar">bar</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#bootstrap">bootstrap</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#cat">cat</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#check">check</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#decimate">decimate</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#count-distinct">count-distinct</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#cut">cut</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#filter">filter</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Field_names_for_filter">Field names for filter</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Built-in_variables_for_filter">Built-in variables for filter</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Expression_formatting_for_filter">Expression formatting for filter</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#grep">grep</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#group-by">group-by</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#group-like">group-like</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#having-fields">having-fields</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#head">head</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#histogram">histogram</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#join">join</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#label">label</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#merge-fields">merge-fields</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#put">put</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Field_names_for_put">Field names for put</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Built-in_variables_for_put">Built-in variables for put</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Expression_formatting_for_put">Expression formatting for put</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Gating_assignments_by_boolean_expressions_for_put">Gating assignments by boolean expressions for put</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#regularize">regularize</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#rename">rename</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#reorder">reorder</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#reshape">reshape</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#sample">sample</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#sec2gmt">sec2gmt</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#sort">sort</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#stats1">stats1</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#stats2">stats2</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#step">step</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#tac">tac</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#tail">tail</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#top">top</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#uniq">uniq</a><br/>
&bull;&nbsp;<a href="#then-chaining">then-chaining</a><br/>
&bull;&nbsp;<a href="#Functions_for_filter_and_put">Functions for filter and put</a><br/>
&bull;&nbsp;<a href="#Operator_precedence">Operator precedence</a><br/>
&bull;&nbsp;<a href="#Operator_and_function_semantics">Operator and function semantics</a><br/>
&bull;&nbsp;<a href="#Arithmetic">Arithmetic</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Input_scanning">Input scanning</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Conversion_by_math_routines">Conversion by math routines</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Conversion_by_arithmetic_operators">Conversion by arithmetic operators</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Pythonic_division">Pythonic division</a><br/>
&bull;&nbsp;<a href="#Regular_expressions">Regular expressions</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="#Regex_captures">Regex captures</a><br/>
</div>
<p/>

<a id="Command_overview"/><h1>Command overview</h1>

<p>
Whereas the Unix toolkit is made of the separate executables <tt>cat</tt>, <tt>tail</tt>, <tt>cut</tt>,
<tt>sort</tt>, etc., Miller has subcommands, invoked as follows:

<p/>
<div class="pokipanel">
<pre>
mlr tac *.dat
mlr cut --complement -f os_version *.dat
mlr sort -f hostname,uptime *.dat
</pre>
</div>
<p/>

<p/>These falls into categories as follows:

<table border=1>
  <tr class="mlrbg">
    <th>Commands </th>
    <th>Description</th>
  </tr>
  <tr>
    <td>
      <a href="#cat"><tt>cat</tt></a>,
      <a href="#cut"><tt>cut</tt></a>,
      <a href="#head"><tt>head</tt></a>,
      <a href="#sort"><tt>sort</tt></a>,
      <a href="#tac"><tt>tac</tt></a>,
      <a href="#tail"><tt>tail</tt></a>,
      <a href="#top"><tt>top</tt></a>,
      <a href="#uniq"><tt>uniq</tt></a>
    </td>
    <td> Analogs of their Unix-toolkit namesakes, discussed below as well as in
    <a href="feature-comparison.html">Miller features in the context of the Unix toolkit</a> </td>
  </tr>

  <tr>
    <td>
      <a href="#filter"><tt>filter</tt></a>,
      <a href="#put"><tt>put</tt></a>,
      <a href="#step"><tt>step</tt></a>
    </td>
    <td> <tt>awk</tt>-like functionality </td>
  </tr>

  <tr>
    <td>
      <a href="#histogram"><tt>histogram</tt></a>,
      <a href="#stats1"><tt>stats1</tt></a>,
      <a href="#stats2"><tt>stats2</tt></a>
    </td>
    <td> Statistically oriented </td>
  </tr>

  <tr>
    <td>
      <a href="#group-by"><tt>group-by</tt></a>,
      <a href="#group-like"><tt>group-like</tt></a>,
      <a href="#having-fields"><tt>having-fields</tt></a>
    </td>
    <td> Particularly oriented toward <a href="record-heterogeneity.html">Record-heterogeneity</a>, although
      all Miller commands can handle heterogeneous records
  </tr>

  <tr>
    <td>
      <a href="#count-distinct"><tt>count-distinct</tt></a>,
      <a href="#label"><tt>label</tt></a>,
      <a href="#regularize"><tt>rename</tt></a>,
      <a href="#rename"><tt>rename</tt></a>,
      <a href="#reorder"><tt>reorder</tt></a>
    </td>
    <td> These draw from other sources (see also <a href="originality.html">How original is Miller?</a>):
      <a href="#count-distinct"><tt>count-distinct</tt></a> is SQL-ish, and
      <a href="#rename"><tt>rename</tt></a> can be done by <tt>sed</tt> (which does it faster:
        see <a href="performance.html">Performance</a>).
    </td>
  </tr>

</table>

<a id="On-line_help"/><h1>On-line help</h1>

<p/>Examples:<p/>

<p/>
<div class="pokipanel">
<pre>
$ mlr --help
Usage: mlr [I/O options] {verb} [verb-dependent options ...] {zero or more file names}

Command-line-syntax examples:
  mlr --csv --rs lf --fs tab cut -f hostname,uptime file1.tsv file2.tsv
  mlr --csv cut -f hostname,uptime mydata.csv
  mlr --csv filter '$status != "down" &amp;&amp; $upsec &gt;= 10000' *.csv
  mlr --nidx put '$sum = $7 + 2.1*$8' *.dat
  grep -v '^#' /etc/group | mlr --ifs : --nidx --opprint label group,pass,gid,member then sort -f group
  mlr join -j account_id -f accounts.dat then group-by account_name balances.dat
  mlr put '$attr = sub($attr, "([0-9]+)_([0-9]+)_.*", "\1:\2")' data/*
  mlr stats1 -a min,mean,max,p10,p50,p90 -f flag,u,v data/*
  mlr stats2 -a linreg-pca -f u,v -g shape data/*

Data-format examples:
  DKVP: delimited key-value pairs (Miller default format)
  +---------------------+
  | apple=1,bat=2,cog=3 |  Record 1: "apple" =&gt; "1", "bat" =&gt; "2", "cog" =&gt; "3"
  | dish=7,egg=8,flint  |  Record 2: "dish" =&gt; "7", "egg" =&gt; "8", "3" =&gt; "flint"
  +---------------------+

  NIDX: implicitly numerically indexed (Unix-toolkit style)
  +---------------------+
  | the quick brown     | Record 1: "1" =&gt; "the", "2" =&gt; "quick", "3" =&gt; "brown"
  | fox jumped          | Record 2: "1" =&gt; "fox", "2" =&gt; "jumped"
  +---------------------+

  CSV/CSV-lite: comma-separated values with separate header line
  +---------------------+
  | apple,bat,cog       |
  | 1,2,3               | Record 1: "apple =&gt; "1", "bat" =&gt; "2", "cog" =&gt; "3"
  | 4,5,6               | Record 2: "apple" =&gt; "4", "bat" =&gt; "5", "cog" =&gt; "6"
  +---------------------+

  Tabular JSON: nested objects are supported, although arrays within them are not:
  +---------------------+
  | {                   |
  |  "apple": 1,        | Record 1: "apple" =&gt; "1", "bat" =&gt; "2", "cog" =&gt; "3"
  |  "bat": 2,          |
  |  "cog": 3           |
  | }                   |
  | {                   |
  |   "dish": {         | Record 2: "dish:egg" =&gt; "7", "dish:flint" =&gt; "8", "garlic" =&gt; ""
  |     "egg": 7,       |
  |     "flint": 8      |
  |   },                |
  |   "garlic": ""      |
  | }                   |
  +---------------------+

  PPRINT: pretty-printed tabular
  +---------------------+
  | apple bat cog       |
  | 1     2   3         | Record 1: "apple =&gt; "1", "bat" =&gt; "2", "cog" =&gt; "3"
  | 4     5   6         | Record 2: "apple" =&gt; "4", "bat" =&gt; "5", "cog" =&gt; "6"
  +---------------------+

  XTAB: pretty-printed transposed tabular
  +---------------------+
  | apple 1             | Record 1: "apple" =&gt; "1", "bat" =&gt; "2", "cog" =&gt; "3"
  | bat   2             |
  | cog   3             |
  |                     |
  | dish 7              | Record 2: "dish" =&gt; "7", "egg" =&gt; "8"
  | egg  8              |
  +---------------------+

Help options:
  -h or --help Show this message.
  --version              Show the software version.
  {verb name} --help     Show verb-specific help.
  --list-all-verbs or -l List only verb names.
  --help-all-verbs       Show help on all verbs.

Verbs:
   bar bootstrap cat check count-distinct cut decimate filter grep group-by
   group-like having-fields head histogram join label merge-fields put
   regularize rename reorder reshape sample sec2gmt sort stats1 stats2 step tac
   tail top uniq

Functions for the filter and put verbs:
   + + - - * / // % ** | ^ &amp; ~ &lt;&lt; &gt;&gt; == != =~ !=~ &gt; &gt;= &lt; &lt;= &amp;&amp; || ^^ ! ? :
   isnull isnotnull boolean float fmtnum hexfmt int string . gsub strlen sub
   tolower toupper abs acos acosh asin asinh atan atan2 atanh cbrt ceil cos
   cosh erf erfc exp expm1 floor invqnorm log log10 log1p logifit madd max mexp
   min mmul msub pow qnorm round roundm sgn sin sinh sqrt tan tanh urand
   urand32 urandint dhms2fsec dhms2sec fsec2dhms fsec2hms gmt2sec hms2fsec
   hms2sec sec2dhms sec2gmt sec2hms strftime strptime systime
Please use "mlr --help-function {function name}" for function-specific help.
Please use "mlr --help-all-functions" or "mlr -f" for help on all functions.

Data-format options, for input, output, or both:
  --idkvp   --odkvp   --dkvp      Delimited key-value pairs, e.g "a=1,b=2"
                                  (this is Miller's default format).

  --inidx   --onidx   --nidx      Implicitly-integer-indexed fields
                                  (Unix-toolkit style).

  --icsv    --ocsv    --csv       Comma-separated value (or tab-separated
                                  with --fs tab, etc.)

  --ipprint --opprint --pprint    Pretty-printed tabular (produces no
                                  output until all input is in).
                      --right     Right-justifies all fields for PPRINT output.

  --ixtab   --oxtab   --xtab      Pretty-printed vertical-tabular.
                      --xvright   Right-justifies values for XTAB format.

  --ijson   --ojson   --json      JSON tabular: sequence or list of one-level
                                  maps: {...}{...} or [{...},{...}].
                      --jvstack   Put one key-value pair per line for JSON
                                  output.
                      --jlistwrap Wrap JSON output in outermost [ ].
                      --jquoteall Quote map keys in JSON output, even if they're
                                  numeric.
              --jflatsep {string} Separator for flattening multi-level JSON keys,
                                  e.g. '{"a":{"b":3}}' becomes a:b =&gt; 3 for
                                  non-JSON formats. Defaults to :.

  -p is a keystroke-saver for --nidx --fs space --repifs

  Examples: --csv for CSV-formatted input and output; --idkvp --opprint for
  DKVP-formatted input and pretty-printed output.

  PLEASE USE "mlr --csv --rs lf" FOR NATIVE UN*X (LINEFEED-TERMINATED) CSV FILES.

Compressed-data options:
  --prepipe {command} This allows Miller to handle compressed inputs. You can do
  without this for single input files, e.g. "gunzip &lt; myfile.csv.gz | mlr ...".
  However, when multiple input files are present, between-file separations are
  lost; also, the FILENAME variable doesn't iterate. Using --prepipe you can
  specify an action to be taken on each input file. This pre-pipe command must
  be able to read from standard input; it will be invoked with
    {command} &lt; {filename}.
  Examples:
    mlr --prepipe 'gunzip'
    mlr --prepipe 'zcat -cf'
    mlr --prepipe 'xz -cd'
    mlr --prepipe cat
  Note that this feature is quite general and is not limited to decompression
  utilities. You can use it to apply per-file filters of your choice.
  For output compression (or other) utilities, simply pipe the output:
    mlr ... | {your compression command}

Separator options, for input, output, or both:
  --rs     --irs     --ors              Record separators, e.g. 'lf' or '\r\n'
  --fs     --ifs     --ofs  --repifs    Field separators, e.g. comma
  --ps     --ips     --ops              Pair separators, e.g. equals sign
  Notes:
  * IPS/OPS are only used for DKVP and XTAB formats, since only in these formats
    do key-value pairs appear juxtaposed.
  * IRS/ORS are ignored for XTAB format. Nominally IFS and OFS are newlines;
    XTAB records are separated by two or more consecutive IFS/OFS -- i.e.
    a blank line.
  * OFS must be single-character for PPRINT format. This is because it is used
    with repetition for alignment; multi-character separators would make
    alignment impossible.
  * OPS may be multi-character for XTAB format, in which case alignment is
    disabled.
  * DKVP, NIDX, CSVLITE, PPRINT, and XTAB formats are intended to handle
    platform-native text data. In particular, this means LF line-terminators
    by default on Linux/OSX. You can use "--dkvp --rs crlf" for
    CRLF-terminated DKVP files, and so on.
  * CSV is intended to handle RFC-4180-compliant data. In particular, this means
    it uses CRLF line-terminators by default. You can use "--csv --rs lf" for
    Linux-native CSV files.
  * All RS/FS/PS options are ignored for JSON format: JSON doesn't allow
    changing these.
  * You can specify separators in any of the following ways, shown by example:
    - Type them out, quoting as necessary for shell escapes, e.g.
      "--fs '|' --ips :"
    - C-style escape sequences, e.g. "--rs '\r\n' --fs '\t'".
    - To avoid backslashing, you can use any of the following names:
      cr crcr newline lf lflf crlf crlfcrlf tab space comma pipe slash colon semicolon equals
  * Default separators by format:
      File format  RS       FS       PS
      dkvp         \n       ,        =
      json         (N/A)    (N/A)    (N/A)
      nidx         \n       space    (N/A)
      csv          \r\n     ,        (N/A)
      csvlite      \n       ,        (N/A)
      pprint       \n       space    (N/A)
      xtab         (N/A)    \n       space

Relevant to CSV/CSV-lite input only:
  --implicit-csv-header Use 1,2,3,... as field labels, rather than from line 1
                     of input files. Tip: combine with "label" to recreate
                     missing headers.
  --headerless-csv-output   Print only CSV data lines.

Double-quoting for CSV output:
  --quote-all        Wrap all fields in double quotes
  --quote-none       Do not wrap any fields in double quotes, even if they have
                     OFS or ORS in them
  --quote-minimal    Wrap fields in double quotes only if they have OFS or ORS
                     in them (default)
  --quote-numeric    Wrap fields in double quotes only if they have numbers
                     in them

Numerical formatting:
  --ofmt {format}    E.g. %.18lf, %.0lf. Please use sprintf-style codes for
                     double-precision. Applies to verbs which compute new
                     values, e.g. put, stats1, stats2. See also the fmtnum
                     function within mlr put (mlr --help-all-functions).
                     Defaults to %lf.

Other options:
  --seed {n} with n of the form 12345678 or 0xcafefeed. For put/filter
                     urand()/urandint()/urand32().

Then-chaining:
Output of one verb may be chained as input to another using "then", e.g.
  mlr stats1 -a min,mean,max -f flag,u,v -g color then sort -f color

For more information please see http://johnkerl.org/miller/doc and/or
http://github.com/johnkerl/miller. This is Miller version v4.0.0-almost.
</pre>
</div>
<p/>

<p/>
<div class="pokipanel">
<pre>
$ mlr sort --help
Usage: mlr sort {flags}
Flags:
  -f  {comma-separated field names}  Lexical ascending
  -n  {comma-separated field names}  Numerical ascending; nulls sort last
  -nf {comma-separated field names}  Numerical ascending; nulls sort last
  -r  {comma-separated field names}  Lexical descending
  -nr {comma-separated field names}  Numerical descending; nulls sort first
Sorts records primarily by the first specified field, secondarily by the second
field, and so on.  Any records not having all specified sort keys will appear
at the end of the output, in the order they were encountered, regardless of the
specified sort order.
Example:
  mlr sort -f a,b -nr x,y,z
which is the same as:
  mlr sort -f a -f b -nr x -nr y -nr z
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="Data_types"/><h1>Data types</h1>

<p/> Miller&rsquo;s input and output are all string-oriented: there is (as of
August 2015 anyway) no support for binary record packing. In this sense,
everything is a string in and out of Miller.  During processing, field names
are always strings, even if they have names like "3"; field values are usually
strings.  Field values&rsquo; ability to be interpreted as a non-string type
only has meaning when comparison or function operations are done on them.  And
it is an error condition if Miller encounters non-numeric (or otherwise
mistyped) data in a field in which it has been asked to do numeric (or
otherwise type-specific) operations.

<p/> Field values are treated as numeric for the following:
<ul>
<li/> Numeric sort: <tt>mlr sort -n</tt>, <tt>mlr sort -nr</tt>.
<li/> Statistics: <tt>mlr histogram</tt>, <tt>mlr stats1</tt>, <tt>mlr stats2</tt>.
<li/> Cross-record arithmetic: <tt>mlr step</tt>.
</ul>

<p/>For <tt>mlr put</tt> and <tt>mlr filter</tt>:

<ul>

<li/> Miller&rsquo;s types for function processing are <b>null</b> (empty
string), <b>error</b>, <b>string</b>, <b>float</b> (double-precision),
<b>int</b> (64-bit signed), and <b>boolean</b>.

<li/> On input, string values representable as numbers, e.g. "3" or "3.1", are
treated as int or float, respectively. If a record has <tt>x=1,y=2</tt> then
<tt>mlr put '$z=$x+$y'</tt> will produce <tt>x=1,y=2,z=3</tt>, and <tt>mlr put
'$z=$x.$y'</tt> gives an error.  To coerce back to string for processing, use
the <tt>string</tt> function: <tt>mlr put '$z=string($x).string($y)'</tt> will
produce <tt>x=1,y=2,z=12</tt>.

<li/> On input, string values representable as boolean  (e.g. <tt>"true"</tt>,
<tt>"false"</tt>) are <i>not</i> automatically treated as boolean.  (This is
because <tt>"true"</tt> and <tt>"false"</tt> are ordinary words, and auto
string-to-boolean on a column consisting of words would result in some strings
mixed with some booleans.) Use the <tt>boolean</tt> function to coerce: e.g.
giving the record <tt>x=1,y=2,w=false</tt> to <tt>mlr put '$z=($x&lt;$y) ||
boolean($w)'</tt>.

<li/> Functions take types as described in <tt>mlr --help-all-functions</tt>:
for example, <tt>log10</tt> takes float input and produces float output,
<tt>gmt2sec</tt> maps string to int, and <tt>sec2gmt</tt> maps int to string.

<li/> All math functions described in <tt>mlr --help-all-functions</tt> take
integer as well as float input.

</ul>

<!-- ================================================================ -->
<a id="Null_data"/><h1>Null data</h1>

<p/> One of Miller&rsquo;s key features is its support for <b>heterogeneous</b> data.
Accordingly, if you try to sort on field <tt>hostname</tt> when not all records in the data
stream <i>have</i> a field named <tt>hostname</tt>, it is not an error (although you could
pre-filter the data stream using <tt>mlr having-fields --at-least hostname then sort ...</tt>).
Rather, records lacking one or more sort keys are simply output contiguously by <tt>mlr sort</tt>.

<p/> Field values may also be null by being
specified with present key but empty value: e.g. sending <tt>x=,y=2</tt> to <tt>mlr put '$z=$x+$y'</tt>.

<p/>
Rules for null-handling:
<ul>
<li> Records with one or more null sort-field values sort after records with all sort-field values present:
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint cat data/sort-null.dat
a b
3 2
1 8
- 4
5 7
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint sort -n  a data/sort-null.dat
a b
1 8
3 2
5 7
- 4
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint sort -nr a data/sort-null.dat
a b
- 4
5 7
3 2
1 8
</pre>
</div>
<p/>
<li> Functions which have one or more null arguments produce null output: e.g.
<p/>
<div class="pokipanel">
<pre>
$ echo 'x=2,y=3' | mlr put '$a=$x+$y'
x=2,y=3,a=5
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ echo 'x=,y=3' | mlr put '$a=$x+$y'
x=,y=3,a=
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ echo 'x=,y=3' | mlr put '$a=log($x);$b=log($y)'
x=,y=3,a=,b=1.098612
</pre>
</div>
<p/>
<li> The <tt>min</tt> and <tt>max</tt> functions are special: if one argument is non-null, it wins:
<p/>
<div class="pokipanel">
<pre>
$ echo 'x=,y=3' | mlr put '$a=min($x,$y);$b=max($x,$y)'
x=,y=3,a=3,b=3
</pre>
</div>
<p/>
</ul>

<!-- ================================================================ -->
<a id="I/O_options"/><h1>I/O options</h1>

<!-- ================================================================ -->
<a id="Formats"/><h2>Formats</h2>

<p/> Options:

<pre>
  --dkvp    --idkvp    --odkvp
  --nidx    --inidx    --onidx
  --csv     --icsv     --ocsv
  --csvlite --icsvlite --ocsvlite
  --pprint  --ipprint  --ppprint  --right
  --xtab    --ixtab    --oxtab
  --json    --ijson    --ojson
</pre>

<p/> These are as discussed in <a href="file-formats.html">File formats</a>, with the exception of <tt>--right</tt>
which makes pretty-printed output right-aligned:

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint cat data/small
a   b   i x                   y
pan pan 1 0.3467901443380824  0.7268028627434533
eks pan 2 0.7586799647899636  0.5221511083334797
wye wye 3 0.20460330576630303 0.33831852551664776
eks wye 4 0.38139939387114097 0.13418874328430463
wye pan 5 0.5732889198020006  0.8636244699032729
</pre>
</div>
<p/>
</td><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint --right cat data/small
  a   b i                   x                   y
pan pan 1  0.3467901443380824  0.7268028627434533
eks pan 2  0.7586799647899636  0.5221511083334797
wye wye 3 0.20460330576630303 0.33831852551664776
eks wye 4 0.38139939387114097 0.13418874328430463
wye pan 5  0.5732889198020006  0.8636244699032729
</pre>
</div>
<p/>
</td></tr></table>

<p/>Additional notes:

<ul>

<li/> Use <tt>--csv</tt>, <tt>--pprint</tt>, etc. when the input and output formats are the same.

<li/> Use <tt>--icsv --opprint</tt>, etc. when you want format conversion as part of what Miller does to your data.

<li/> DKVP (key-value-pair) format is the default for input and output. So,
<tt>--oxtab</tt> is the same as <tt>--idkvp --oxtab</tt>.

</ul>

<!-- ================================================================ -->
<a id="Compression"/><h2>Compression</h2>

<p/> Options:

<pre>
  --prepipe {command}
</pre>

<p/>The prepipe command is anything which reads from standard input and produces data acceptable to
Miller. Nominally this allows you to use whichever decompression utilities you have installed on your
system, on a per-file basis. If the command has flags, quote them: e.g. <tt>mlr --prepipe 'zcat -cf'</tt>. Examples:

<p/>
<div class="pokipanel">
<pre>
# These two produce the same output:
$ gunzip &lt; myfile1.csv.gz | mlr cut -f hostname,uptime
$ mlr --prepipe gunzip cut -f hostname,uptime myfile1.csv.gz
# With multiple input files you need --prepipe:
$ mlr --prepipe gunzip cut -f hostname,uptime myfile1.csv.gz myfile2.csv.gz
$ mlr --prepipe gunzip --idkvp --oxtab cut -f hostname,uptime myfile1.dat.gz myfile2.dat.gz

# Similar to the above, but with compressed output as well as input:
$ gunzip &lt; myfile1.csv.gz | mlr cut -f hostname,uptime | gzip &gt; outfile.csv.gz
$ mlr --prepipe gunzip cut -f hostname,uptime myfile1.csv.gz | gzip &gt; outfile.csv.gz
$ mlr --prepipe gunzip cut -f hostname,uptime myfile1.csv.gz myfile2.csv.gz | gzip &gt; outfile.csv.gz

# Similar to the above, but with different compression tools for input and output:
$ gunzip &lt; myfile1.csv.gz | mlr cut -f hostname,uptime | xz -z &gt; outfile.csv.xz
$ xz -cd &lt; myfile1.csv.xz | mlr cut -f hostname,uptime | gzip &gt; outfile.csv.xz
$ mlr --prepipe 'xz -cd' cut -f hostname,uptime myfile1.csv.xz myfile2.csv.xz | xz -z &gt; outfile.csv.xz

... etc.
</pre>
</div>

<!-- ================================================================ -->
<a id="Record/field/pair_separators"/><h2>Record/field/pair separators</h2>

<p/> Miller has record separators <tt>IRS</tt> and <tt>ORS</tt>, field
separators <tt>IFS</tt> and <tt>OFS</tt>, and pair separators <tt>IPS</tt> and
<tt>OPS</tt>.  For example, in the DKVP line <tt>a=1,b=2,c=3</tt>, the record
separator is newline, field separator is comma, and pair separator is the
equals sign. These are the default values.

<p/> Options:
<pre>
  --rs --irs --ors
  --fs --ifs --ofs --repifs
  --ps --ips --ops
</pre>

<ul>

<li/> You can change a separator from input to output via e.g. <tt>--ifs =
--ofs :</tt>. Or, you can specify that the same separator is to be used for
input and output via e.g. <tt>--fs :</tt>.

<li/> The pair separator is only relevant to DKVP format.

<li/> Pretty-print and xtab formats ignore the separator arguments altogether.

<li/> The <tt>--repifs</tt> means that multiple successive occurrences of the
field separator count as one.  For example, in CSV data we often signify nulls
by empty strings, e.g. <tt>2,9,,,,,6,5,4</tt>. On the other hand, if the field
separator is a space, it might be more natural to parse <tt>2 4    5</tt> the
same as <tt>2 4 5</tt>: <tt>--repifs --ifs ' '</tt> lets this happen.  In fact,
the <tt>--ipprint</tt> option above is internally implemented in terms of
<tt>--repifs</tt>.

<li/> Just write out the desired separator, e.g. <tt>--ofs '|'</tt>. But you
may use the symbolic names <tt>newline</tt>, <tt>space</tt>, <tt>tab</tt>,
<tt>pipe</tt>, or <tt>semicolon</tt> if you like.

</ul>

<!-- ================================================================ -->
<a id="Number_formatting"/><h2>Number formatting</h2>

<p/> The command-line option <tt>--ofmt {format string}</tt> is the global
number format for commands which generate numeric output, e.g.
<tt>stats1</tt>, <tt>stats2</tt>, <tt>histogram</tt>, and <tt>step</tt>, as
well as <tt>mlr put</tt>. Examples:

<p/>
<div class="pokipanel">
<pre>
--ofmt %.9le  --ofmt %.6lf  --ofmt %.0lf
</pre>
</div>
<p/>

<p/> These are just C <tt>printf</tt> formats applied to double-precision
numbers.  Please don&rsquo;t use <tt>%s</tt> or <tt>%d</tt>. Additionally, if
you use leading width (e.g. <tt>%18.12lf</tt>) then the output will contain
embedded whitespace, which may not be what you want if you pipe the output to
something else, particularly CSV. I use Miller&rsquo;s pretty-print format
(<tt>mlr --opprint</tt>) to column-align numerical data.

<p/> To apply formatting to a single field, overriding the global
<tt>ofmt</tt>, use <tt>fmtnum</tt> function within <tt>mlr put</tt>. For example:
<p/>
<div class="pokipanel">
<pre>
$ echo 'x=3.1,y=4.3' | mlr put '$z=fmtnum($x*$y,"%08lf")'
x=3.1,y=4.3,z=13.330000
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ echo 'x=0xffff,y=0xff' | mlr put '$z=fmtnum(int($x*$y),"%08llx")'
x=0xffff,y=0xff,z=00feff01
</pre>
</div>
<p/>

<p/>Input conversion from hexadecimal is done automatically on fields handled
by <tt>mlr put</tt> and <tt>mlr filter</tt> as long as the field value begins
with "0x".  To apply output conversion to hexadecimal on a single column, you
may use <tt>fmtnum</tt>, or the keystroke-saving <tt>hexfmt</tt> function.
Example:

<p/>
<div class="pokipanel">
<pre>
$ echo 'x=0xffff,y=0xff' | mlr put '$z=hexfmt($x*$y)'
x=0xffff,y=0xff,z=0xfeff01
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="Data_transformations"/><h1>Data transformations</h1>

<!-- ================================================================ -->
<a id="bar"/><h2>bar</h2>

<p/> Cheesy bar-charting.

<p/>
<div class="pokipanel">
<pre>
$ mlr bar -h
Usage: mlr bar [options]
Replaces a numeric field with a number of asterisks, allowing for cheesy
bar plots. These align best with --opprint or --oxtab output format.
Options:
-f   {a,b,c}      Field names to convert to bars.
-c   {character}  Fill character: default '*'.
-x   {character}  Out-of-bounds character: default '#'.
-b   {character}  Blank character: default '.'.
--lo {lo}         Lower-limit value for min-width bar: default '0.000000'.
--hi {hi}         Upper-limit value for max-width bar: default '100.000000'.
-w   {n}          Bar-field width: default '40'.
--auto            Automatically computes limits, ignoring --lo and --hi.
                  Holds all records in memory before producing any output.
</pre>
</div>
<p/>

<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint cat data/small
a   b   i x                   y
pan pan 1 0.3467901443380824  0.7268028627434533
eks pan 2 0.7586799647899636  0.5221511083334797
wye wye 3 0.20460330576630303 0.33831852551664776
eks wye 4 0.38139939387114097 0.13418874328430463
wye pan 5 0.5732889198020006  0.8636244699032729
</pre>
</div>
<p/>

<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint bar --lo 0 --hi 1 -f x,y data/small
a   b   i x                                        y
pan pan 1 *************........................... *****************************...........
eks pan 2 ******************************.......... ********************....................
wye wye 3 ********................................ *************...........................
eks wye 4 ***************......................... *****...................................
wye pan 5 **********************.................. **********************************......
</pre>
</div>
<p/>

<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint bar --lo 0.4 --hi 0.6 -f x,y data/small
a   b   i x                                        y
pan pan 1 #....................................... ***************************************#
eks pan 2 ***************************************# ************************................
wye wye 3 #....................................... #.......................................
eks wye 4 #....................................... #.......................................
wye pan 5 **********************************...... ***************************************#
</pre>
</div>
<p/>

<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint bar --auto -f x,y data/small
a   b   i x                                                           y
pan pan 1 [0.204603]**********..............................[0.75868] [0.134189]********************************........[0.863624]
eks pan 2 [0.204603]***************************************#[0.75868] [0.134189]*********************...................[0.863624]
wye wye 3 [0.204603]#.......................................[0.75868] [0.134189]***********.............................[0.863624]
eks wye 4 [0.204603]************............................[0.75868] [0.134189]#.......................................[0.863624]
wye pan 5 [0.204603]**************************..............[0.75868] [0.134189]***************************************#[0.863624]
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="bootstrap"/><h2>bootstrap</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr bootstrap --help
Usage: mlr bootstrap [options]
Emits an n-sample, with replacement, of the input records.
Options:
-n {number} Number of samples to output. Defaults to number of input records.
            Must be non-negative.
</pre>
</div>
<p/>

<p/> The canonical use for bootstrap sampling is to put error bars on statistical quantities, such as mean. For example:

<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint stats1 -a mean,count -f u -g color data/colored-shapes.dkvp 
color  u_mean   u_count
yellow 0.497129 1413
red    0.492560 4641
purple 0.494005 1142
green  0.504861 1109
blue   0.517717 1470
orange 0.490532 303

$ mlr --opprint bootstrap then stats1 -a mean,count -f u -g color data/colored-shapes.dkvp 
color  u_mean   u_count
yellow 0.500651 1380
purple 0.501556 1111
green  0.503272 1068
red    0.493895 4702
blue   0.512529 1496
orange 0.521030 321

$ mlr --opprint bootstrap then stats1 -a mean,count -f u -g color data/colored-shapes.dkvp 
color  u_mean   u_count
yellow 0.498046 1485
blue   0.513576 1417
red    0.492870 4595
orange 0.507697 307
green  0.496803 1075
purple 0.486337 1199

$ mlr --opprint bootstrap then stats1 -a mean,count -f u -g color data/colored-shapes.dkvp 
color  u_mean   u_count
blue   0.522921 1447
red    0.490717 4617
yellow 0.496450 1419
purple 0.496523 1192
green  0.507569 1111
orange 0.468014 292
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="cat"/><h2>cat</h2>

<p/> Most useful for format conversions (see
<a href="file-formats.html">File formats</a>), and concatenating multiple
same-schema CSV files to have the same header:

<p/>
<div class="pokipanel">
<pre>
$ mlr cat -h
Usage: mlr cat [options]
Passes input records directly to output. Most useful for format conversion.
Options:
-n        Prepend field "n" to each record with record-counter starting at 1
-N {name} Prepend field {name} to each record with record-counter starting at 1
</pre>
</div>
<p/>

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ cat data/a.csv
a,b,c
1,2,3
4,5,6
</pre>
</div>
<p/>
</td> <td>
<p/>
<div class="pokipanel">
<pre>
$ cat data/b.csv
a,b,c
7,8,9
</pre>
</div>
<p/>
</td> <td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --csv cat data/a.csv data/b.csv
a,b,c
1,2,3
4,5,6
7,8,9
</pre>
</div>
<p/>
</td></tr></table>

<table><tr><td>
</td> <td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --icsv --oxtab cat data/a.csv data/b.csv
a 1
b 2
c 3

a 4
b 5
c 6

a 7
b 8
c 9
</pre>
</div>
<p/>
</td> <td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --csv cat -n data/a.csv data/b.csv
n,a,b,c
0,1,2,3
1,4,5,6
2,7,8,9
</pre>
</div>
<p/>
</td></tr></table>

<!-- ================================================================ -->
<a id="check"/><h2>check</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr check --help
Usage: mlr check
Consumes records without printing any output.
Useful for doing a well-formatted check on input data.
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="decimate"/><h2>decimate</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr decimate --help
Usage: mlr decimate [options]
-n {count}    Decimation factor; default 10
-b            Decimate by printing first of every n.
-e            Decimate by printing last of every n (default).
-g {a,b,c}    Optional group-by-field names for decimate counts
Passes through one of every n records, optionally by category.
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="count-distinct"/><h2>count-distinct</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr count-distinct --help
Usage: mlr count-distinct [options]
-f {a,b,c}    Field names for distinct count.
-n            Show only the number of distinct values.
Prints number of records having distinct values for specified field names.
Same as uniq -c.
</pre>
</div>
<p/>

<p/>
<div class="pokipanel">
<pre>
$ mlr count-distinct -f a,b then sort -nr count data/medium
a=zee,b=wye,count=455
a=pan,b=eks,count=429
a=pan,b=pan,count=427
a=wye,b=hat,count=426
a=hat,b=wye,count=423
a=pan,b=hat,count=417
a=eks,b=hat,count=417
a=eks,b=eks,count=413
a=pan,b=zee,count=413
a=zee,b=hat,count=409
a=eks,b=wye,count=407
a=zee,b=zee,count=403
a=pan,b=wye,count=395
a=wye,b=pan,count=392
a=zee,b=eks,count=391
a=zee,b=pan,count=389
a=hat,b=eks,count=389
a=wye,b=eks,count=386
a=hat,b=zee,count=385
a=wye,b=zee,count=385
a=hat,b=hat,count=381
a=wye,b=wye,count=377
a=eks,b=pan,count=371
a=hat,b=pan,count=363
a=eks,b=zee,count=357
</pre>
</div>
<p/>

<p/>
<div class="pokipanel">
<pre>
$ mlr count-distinct -n -f a,b data/medium
count=25
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="cut"/><h2>cut</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr cut --help
Usage: mlr cut [options]
Passes through input records with specified fields included/excluded.
-f {a,b,c}       Field names to include for cut.
-o               Retain fields in the order specified here in the argument list.
                 Default is to retain them in the order found in the input data.
-x|--complement  Exclude, rather than include, field names specified by -f.
-r               Treat field names as regular expressions. "ab", "a.*b" will
                 match any field name containing the substring "ab" or matching
                 "a.*b", respectively; anchors of the form "^ab$", "^a.*b$" may
                 be used. The -o flag is ignored when -r is present.
Examples:
  mlr cut -f hostname,status
  mlr cut -x -f hostname,status
  mlr cut -r -f '^status$,sda[0-9]'
  mlr cut -r -f '^status$,"sda[0-9]"'
  mlr cut -r -f '^status$,"sda[0-9]"i' (this is case-insensitive)
</pre>
</div>
<p/>

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint cat data/small
a   b   i x                   y
pan pan 1 0.3467901443380824  0.7268028627434533
eks pan 2 0.7586799647899636  0.5221511083334797
wye wye 3 0.20460330576630303 0.33831852551664776
eks wye 4 0.38139939387114097 0.13418874328430463
wye pan 5 0.5732889198020006  0.8636244699032729
</pre>
</div>
<p/>
</td><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint cut -f y,x,i data/small
i x                   y
1 0.3467901443380824  0.7268028627434533
2 0.7586799647899636  0.5221511083334797
3 0.20460330576630303 0.33831852551664776
4 0.38139939387114097 0.13418874328430463
5 0.5732889198020006  0.8636244699032729
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ echo 'a=1,b=2,c=3' | mlr cut -f b,c,a
a=1,b=2,c=3
</pre>
</div>
<p/>
</td><td>
<p/>
<div class="pokipanel">
<pre>
$ echo 'a=1,b=2,c=3' | mlr cut -o -f b,c,a
b=2,c=3,a=1
</pre>
</div>
<p/>
</td></tr></table>

<p/>
<!-- ================================================================ -->
<a id="filter"/><h2>filter</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr filter --help
Usage: mlr filter [options] {expression}
Prints records for which {expression} evaluates to true.

Options:
-v: First prints the AST (abstract syntax tree) for the expression, which gives
    full transparency on the precedence and associativity rules of Miller's
    grammar.
-S: Keeps field values, or literals in the expression, as strings with no type
    inference to int or float.
-F: Keeps field values, or literals in the expression, as strings or floats
    with no inference to int.
-x: Prints records for which {expression} evaluates to false.

Please use a dollar sign for field names and double-quotes for string
literals. If field names have special characters such as "." then you might
use braces, e.g. '${field.name}'. Miller built-in variables are
NF NR FNR FILENUM FILENAME PI E.

Examples:
  mlr filter 'log10($count) &gt; 4.0'
  mlr filter 'FNR == 2          (second record in each file)'
  mlr filter 'urand() &lt; 0.001'  (subsampling)
  mlr filter '$color != "blue" &amp;&amp; $value &gt; 4.2'
  mlr filter '($x&lt;.5 &amp;&amp; $y&lt;.5) || ($x&gt;.5 &amp;&amp; $y&gt;.5)'
  mlr filter '($name =~ "^sys.*east$") || ($name =~ "^dev.[0-9]+"i)'

Please see http://johnkerl.org/miller/doc/reference.html for more information
including function list. Or "mlr -f". Please also also "mlr grep" which is
useful when you don't yet know which field name(s) you're looking for.
</pre>
</div>
<p/>

<a id="Field_names_for_filter"/><h3>Field names for filter</h3>

<p/>Field names must be specified using a <tt>$</tt> in <tt>filter</tt> and <a
href="#put"><tt>put</tt></a> expressions, even though they don&rsquo;t appear
in the data stream. For integer-indexed data, this looks like
<tt>awk</tt>&rsquo;s <tt>$1,$2,$3</tt>.  Likewise, enclose string literals in
double quotes in <tt>filter</tt> expressions even though they don&rsquo;t
appear in file data.  In particular, <tt>mlr filter '$x=="abc"'</tt> passes
through the record <tt>x=abc</tt>.  If field names have special characters such
as <tt>.</tt> then you can use braces, e.g. <tt>'${field.name}'</tt>.

<a id="Built-in_variables_for_filter"/><h3>Built-in variables for filter</h3>

<p/>The <tt>filter</tt> command supports the same built-in variables as for <a
href="#put"><tt>put</tt></a>, all <tt>awk</tt>-inspired: <tt>NF</tt>,
<tt>NR</tt>, <tt>FNR</tt>, <tt>FILENUM</tt>, and <tt>FILENAME</tt>, as well as
the mathematical constants <tt>PI</tt> and <tt>E</tt>. This selects the 2nd
record from each matching file:

<p/>
<div class="pokipanel">
<pre>
$ mlr filter 'FNR == 2' data/small*
a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797
1=pan,2=pan,3=1,4=0.3467901443380824,5=0.7268028627434533
a=wye,b=eks,i=10000,x=0.734806020620654365,y=0.884788571337605134
</pre>
</div>
<p/>

<a id="Expression_formatting_for_filter"/><h3>Expression formatting for filter</h3>

<p/>Expressions may be arbitrarily complex:

<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint filter '$a == "pan" || $b == "wye"' data/small
a   b   i x                   y
pan pan 1 0.3467901443380824  0.7268028627434533
wye wye 3 0.20460330576630303 0.33831852551664776
eks wye 4 0.38139939387114097 0.13418874328430463
</pre>
</div>
<p/>

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint filter '($x &gt; 0.5 &amp;&amp; $y &gt; 0.5) || ($x &lt; 0.5 &amp;&amp; $y &lt; 0.5)' then stats2 -a corr -f x,y data/medium
x_y_corr
0.756439
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint filter '($x &gt; 0.5 &amp;&amp; $y &lt; 0.5) || ($x &lt; 0.5 &amp;&amp; $y &gt; 0.5)' then stats2 -a corr -f x,y data/medium
x_y_corr
-0.747994
</pre>
</div>
<p/>
</td></tr></table>

Newlines within the expression are ignored, which can help increase legibility of complex expressions:

<p/>
<div class="pokipanel">
<pre>
mlr --opprint filter '
  ($x &gt; 0.5 &amp;&amp; $y &lt; 0.5)
  ||
  ($x &lt; 0.5 &amp;&amp; $y &gt; 0.5)' \
  then stats2 -a corr -f x,y data/medium
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="grep"/><h2>grep</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr grep -h
Usage: mlr grep [options] {regular expression}
Passes through records which match {regex}.
Options:
-i    Use case-insensitive search.
-v    Invert: pass through records which do not match the regex.
Note that "mlr filter" is more powerful, but requires you to know field names.
By contrast, "mlr grep" allows you to regex-match the entire record. It does
this by formatting each record in memory as DKVP, using command-line-specified
ORS/OFS/OPS, and matching the resulting line against the regex specified
here. In particular, the regex is not applied to the input stream: if you
have CSV with header line "x,y,z" and data line "1,2,3" then the regex will
be matched, not against either of these lines, but against the DKVP line
"x=1,y=2,z=3".  Furthermore, not all the options to system grep are supported,
and this command is intended to be merely a keystroke-saver. To get all the
features of system grep, you can do
  "mlr --odkvp ... | grep ... | mlr --idkvp ..."
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="group-by"/><h2>group-by</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr group-by --help
Usage: mlr group-by {comma-separated field names}
Outputs records in batches having identical values at specified field names.
</pre>
</div>
<p/>

<p/>This is similar to <tt>sort</tt> but with less work. Namely, Miller&rsquo;s
sort has three steps: read through the data and append linked lists of records,
one for each unique combination of the key-field values; after all records
are read, sort the key-field values; then print each record-list. The group-by
operation simply omits the middle sort.  An example should make this more
clear.

<table><tr> <td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint group-by a data/small
a   b   i x                   y
pan pan 1 0.3467901443380824  0.7268028627434533
eks pan 2 0.7586799647899636  0.5221511083334797
eks wye 4 0.38139939387114097 0.13418874328430463
wye wye 3 0.20460330576630303 0.33831852551664776
wye pan 5 0.5732889198020006  0.8636244699032729
</pre>
</div>
<p/>
</td> <td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint sort -f a data/small
a   b   i x                   y
eks pan 2 0.7586799647899636  0.5221511083334797
eks wye 4 0.38139939387114097 0.13418874328430463
pan pan 1 0.3467901443380824  0.7268028627434533
wye wye 3 0.20460330576630303 0.33831852551664776
wye pan 5 0.5732889198020006  0.8636244699032729
</pre>
</div>
<p/>
</td> </tr></table>

<p/>In this example, since the sort is on field <tt>a</tt>, the first step is
to group together all records having the same value for field <tt>a</tt>; the
second step is to sort the distinct <tt>a</tt>-field values <tt>pan</tt>,
<tt>eks</tt>, and <tt>wye</tt> into <tt>eks</tt>, <tt>pan</tt>, and
<tt>wye</tt>; the third step is to print out the record-list for
<tt>a=eks</tt>, then the record-list for <tt>a=pan</tt>, then the record-list
for <tt>a=wye</tt>.  The group-by operation omits the middle sort and just puts
like records together, for those times when a sort isn&rsquo;t desired. In
particular, the ordering of group-by fields for group-by is the order in which
they were encountered in the data stream, which in some cases may be more interesting
to you.

<!-- ================================================================ -->
<a id="group-like"/><h2>group-like</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr group-like --help
Usage: mlr group-like
Outputs records in batches having identical field names.
</pre>
</div>
<p/>

<p/> This groups together records having the same schema (i.e. same ordered list of field names)
which is useful for making sense of time-ordered output as described in
<a href="record-heterogeneity.html">Record-heterogeneity</a> &mdash; in particular, in
preparation for CSV or pretty-print output.

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr cat data/het.dkvp
resource=/path/to/file,loadsec=0.45,ok=true
record_count=100,resource=/path/to/file
resource=/path/to/second/file,loadsec=0.32,ok=true
record_count=150,resource=/path/to/second/file
resource=/some/other/path,loadsec=0.97,ok=false
</pre>
</div>
<p/>
</td><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint group-like data/het.dkvp
resource             loadsec ok
/path/to/file        0.45    true
/path/to/second/file 0.32    true
/some/other/path     0.97    false

record_count resource
100          /path/to/file
150          /path/to/second/file
</pre>
</div>
<p/>
</td></tr></table>

<!-- ================================================================ -->
<a id="having-fields"/><h2>having-fields</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr having-fields --help
Usage: mlr having-fields [options]
Conditionally passes through records depending on each record's field names.
Options:
  --at-least      {comma-separated names}
  --which-are     {comma-separated names}
  --at-most       {comma-separated names}
  --all-matching  {regular expression}
  --any-matching  {regular expression}
  --none-matching {regular expression}
Examples:
  mlr having-fields --which-are amount,status,owner
  mlr having-fields --any-matching 'sda[0-9]'
  mlr having-fields --any-matching '"sda[0-9]"'
  mlr having-fields --any-matching '"sda[0-9]"i' (this is case-insensitive)
</pre>
</div>
<p/>

<p/> Similar to <a href="#group-like"><tt>group-like</tt></a>, this retains records with specified schema.

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr cat data/het.dkvp
resource=/path/to/file,loadsec=0.45,ok=true
record_count=100,resource=/path/to/file
resource=/path/to/second/file,loadsec=0.32,ok=true
record_count=150,resource=/path/to/second/file
resource=/some/other/path,loadsec=0.97,ok=false
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr having-fields --at-least resource data/het.dkvp
resource=/path/to/file,loadsec=0.45,ok=true
record_count=100,resource=/path/to/file
resource=/path/to/second/file,loadsec=0.32,ok=true
record_count=150,resource=/path/to/second/file
resource=/some/other/path,loadsec=0.97,ok=false
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr having-fields --which-are resource,ok,loadsec data/het.dkvp
resource=/path/to/file,loadsec=0.45,ok=true
resource=/path/to/second/file,loadsec=0.32,ok=true
resource=/some/other/path,loadsec=0.97,ok=false
</pre>
</div>
<p/>
</td></tr></table>

<!-- ================================================================ -->
<a id="head"/><h2>head</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr head --help
Usage: mlr head [options]
-n {count}    Head count to print; default 10
-g {a,b,c}    Optional group-by-field names for head counts
Passes through the first n records, optionally by category.
</pre>
</div>
<p/>

Note that <tt>head</tt> is distinct from <a href="#top"><tt>top</tt></a>
&mdash; <tt>head</tt> shows fields which appear first in the data stream;
<tt>top</tt> shows fields which are numerically largest (or smallest).

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint head -n 4 data/medium
a   b   i x                   y
pan pan 1 0.3467901443380824  0.7268028627434533
eks pan 2 0.7586799647899636  0.5221511083334797
wye wye 3 0.20460330576630303 0.33831852551664776
eks wye 4 0.38139939387114097 0.13418874328430463
</pre>
</div>
<p/>
</td><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint head -n 1 -g b data/medium
a   b   i  x                   y
pan pan 1  0.3467901443380824  0.7268028627434533
wye wye 3  0.20460330576630303 0.33831852551664776
eks zee 7  0.6117840605678454  0.1878849191181694
zee eks 17 0.29081949506712723 0.054478717073354166
wye hat 24 0.7286126830627567  0.19441962592638418
</pre>
</div>
<p/>
</td></tr></table>

<!-- ================================================================ -->
<a id="histogram"/><h2>histogram</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr histogram --help
Usage: mlr histogram [options]
-f {a,b,c}    Value-field names for histogram counts
--lo {lo}     Histogram low value
--hi {hi}     Histogram high value
--nbins {n}   Number of histogram bins
--auto        Automatically computes limits, ignoring --lo and --hi.
              Holds all values in memory before producing any output.
Just a histogram. Input values &lt; lo or &gt; hi are not counted.
</pre>
</div>
<p/>

This is just a histogram; there&rsquo;s not too much to say here. A note about
binning, by example: Suppose you use <tt>--lo 0.0 --hi 1.0 --nbins 10 -f
x</tt>.  The input numbers less than 0 or greater than 1 aren&rsquo;t counted
in any bin.  Input numbers equal to 1 are counted in the last bin. That is, bin
0 has <tt>0.0 &le; x &lt; 0.1</tt>, bin 1 has <tt>0.1 &le; x &lt; 0.2</tt>,
etc., but bin 9 has <tt>0.9 &le; x &le; 1.0</tt>.

<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint put '$x2=$x**2;$x3=$x2*$x' then histogram -f x,x2,x3 --lo 0 --hi 1 --nbins 10 data/medium
bin_lo   bin_hi   x_count x2_count x3_count
0.000000 0.100000 1072    3231     4661
0.100000 0.200000 938     1254     1184
0.200000 0.300000 1037    988      845
0.300000 0.400000 988     832      676
0.400000 0.500000 950     774      576
0.500000 0.600000 1002    692      476
0.600000 0.700000 1007    591      438
0.700000 0.800000 1007    560      420
0.800000 0.900000 986     571      383
0.900000 1.000000 1013    507      341
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="join"/><h2>join</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr join --help
Usage: mlr join [options]
Joins records from specified left file name with records from all file names
at the end of the Miller argument list.
Functionality is essentially the same as the system "join" command, but for
record streams.
Options:
  -f {left file name}
  -j {a,b,c}   Comma-separated join-field names for output
  -l {a,b,c}   Comma-separated join-field names for left input file;
               defaults to -j values if omitted.
  -r {a,b,c}   Comma-separated join-field names for right input file(s);
               defaults to -j values if omitted.
  --lp {text}  Additional prefix for non-join output field names from
               the left file
  --rp {text}  Additional prefix for non-join output field names from
               the right file(s)
  --np         Do not emit paired records
  --ul         Emit unpaired records from the left file
  --ur         Emit unpaired records from the right file(s)
  -u           Enable unsorted input. In this case, the entire left file will
               be loaded into memory. Without -u, records must be sorted
               lexically by their join-field names, else not all records will
               be paired.
  --prepipe {command} As in main input options; see mlr --help for details.
               If you wish to use a prepipe command for the main input as well
               as here, it must be specified there as well as here.
File-format options default to those for the right file names on the Miller
argument list, but may be overridden for the left file as follows. Please see
the main "mlr --help" for more information on syntax for these arguments.
  -i {one of csv,dkvp,nidx,pprint,xtab}
  --irs {record-separator character}
  --ifs {field-separator character}
  --ips {pair-separator character}
  --repifs
  --repips
  --use-mmap
  --no-mmap
Please see http://johnkerl.org/miller/doc/reference.html for more information
including examples.
</pre>
</div>
<p/>

Examples:

<p/>Join larger table with IDs with smaller ID-to-name lookup table, showing only paired records:

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --icsvlite --opprint cat data/join-left-example.csv
id  name
100 alice
200 bob
300 carol
400 david
500 edgar
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --icsvlite --opprint cat data/join-right-example.csv
status  idcode
present 400
present 100
missing 200
present 100
present 200
missing 100
missing 200
present 300
missing 600
present 400
present 400
present 300
present 100
missing 400
present 200
present 200
present 200
present 200
present 400
present 300
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --icsvlite --opprint join -u -j id -r idcode -f data/join-left-example.csv data/join-right-example.csv
id  name  status
400 david present
100 alice present
200 bob   missing
100 alice present
200 bob   present
100 alice missing
200 bob   missing
300 carol present
400 david present
400 david present
300 carol present
100 alice present
400 david missing
200 bob   present
200 bob   present
200 bob   present
200 bob   present
400 david present
300 carol present
</pre>
</div>
<p/>
</td></tr></table>

<p/>Same, but with sorting the input first:
<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --icsvlite --opprint sort -f idcode then join -j id -r idcode -f data/join-left-example.csv data/join-right-example.csv
id  name  status
100 alice present
100 alice present
100 alice missing
100 alice present
200 bob   missing
200 bob   present
200 bob   missing
200 bob   present
200 bob   present
200 bob   present
200 bob   present
300 carol present
300 carol present
300 carol present
400 david present
400 david present
400 david present
400 david missing
400 david present
</pre>
</div>
<p/>
</td></tr></table>

<p/>Same, but showing only unpaired records:
<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --icsvlite --opprint join --np --ul --ur -u -j id -r idcode -f data/join-left-example.csv data/join-right-example.csv
status  idcode
missing 600

id  name
500 edgar
</pre>
</div>
<p/>
</td></tr></table>

<p/>Use prefixing options to disambiguate between otherwise identical non-join field names:
<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --csvlite --opprint cat data/self-join.csv data/self-join.csv
a b c
1 2 3
1 4 5
1 2 3
1 4 5
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --csvlite --opprint join -j a --lp left_ --rp right_ -f data/self-join.csv data/self-join.csv
a left_b left_c right_b right_c
1 2      3      2       3
1 4      5      2       3
1 2      3      4       5
1 4      5      4       5
</pre>
</div>
<p/>
</td></tr></table>

<p/>Use zero join columns:
<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --csvlite --opprint join -j "" --lp left_ --rp right_ -f data/self-join.csv data/self-join.csv
left_a left_b left_c right_a right_b right_c
1      2      3      1       2       3
1      4      5      1       2       3
1      2      3      1       4       5
1      4      5      1       4       5
</pre>
</div>
<p/>
</td></tr></table>

<!-- ================================================================ -->
<a id="label"/><h2>label</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr label --help
Usage: mlr label {new1,new2,new3,...}
Given n comma-separated names, renames the first n fields of each record to
have the respective name. (Fields past the nth are left with their original
names.) Particularly useful with --inidx or --implicit-csv-header, to give
useful names to otherwise integer-indexed fields.
Examples:
  "echo 'a b c d' | mlr --inidx --odkvp cat"       gives "1=a,2=b,3=c,4=d"
  "echo 'a b c d' | mlr --inidx --odkvp label s,t" gives "s=a,t=b,3=c,4=d"
</pre>
</div>
<p/>

See also <a href="#rename"><tt>rename</tt></a>.

<p/>Example: Files such as <tt>/etc/passwd</tt>, <tt>/etc/group</tt>, and so on
have implicit field names which are found in section-5 manpages. These field names may be made explicit as follows:

<p/>
<div class="pokipanel">
<pre>
% grep -v '^#' /etc/passwd | mlr --nidx --fs : --opprint label name,password,uid,gid,gecos,home_dir,shell | head
name                  password uid gid gecos                         home_dir           shell
nobody                *        -2  -2  Unprivileged User             /var/empty         /usr/bin/false
root                  *        0   0   System Administrator          /var/root          /bin/sh
daemon                *        1   1   System Services               /var/root          /usr/bin/false
_uucp                 *        4   4   Unix to Unix Copy Protocol    /var/spool/uucp    /usr/sbin/uucico
_taskgated            *        13  13  Task Gate Daemon              /var/empty         /usr/bin/false
_networkd             *        24  24  Network Services              /var/networkd      /usr/bin/false
_installassistant     *        25  25  Install Assistant             /var/empty         /usr/bin/false
_lp                   *        26  26  Printing Services             /var/spool/cups    /usr/bin/false
_postfix              *        27  27  Postfix Mail Server           /var/spool/postfix /usr/bin/false
</pre>
</div>
<p/>

<p/>Likewise, if you have CSV/CSV-lite input data which has somehow been bereft of its header line, you can re-add a header line using <tt>--implicit-csv-header</tt> and <tt>label</tt>:

<p/>
<div class="pokipanel">
<pre>
$ cat data/headerless.csv
John,23,present
Fred,34,present
Alice,56,missing
Carol,45,present
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr --csv --rs lf --implicit-csv-header cat data/headerless.csv
1,2,3
John,23,present
Fred,34,present
Alice,56,missing
Carol,45,present
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr --csv --rs lf --implicit-csv-header label name,age,status data/headerless.csv
name,age,status
John,23,present
Fred,34,present
Alice,56,missing
Carol,45,present
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr --icsv --rs lf --implicit-csv-header --opprint label name,age,status data/headerless.csv
name  age status
John  23  present
Fred  34  present
Alice 56  missing
Carol 45  present
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="merge-fields"/><h2>merge-fields</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr merge-fields --help
Usage: mlr merge-fields [options]
Computes univariate statistics for each input record, accumulated across
specified fields.
Options:
-a {sum,count,...}  Names of accumulators. One or more of:
  count     Count instances of fields
  mode      Find most-frequently-occurring values for fields; first-found wins tie
  sum       Compute sums of specified fields
  mean      Compute averages (sample means) of specified fields
  stddev    Compute sample standard deviation of specified fields
  var       Compute sample variance of specified fields
  meaneb    Estimate error bars for averages (assuming no sample autocorrelation)
  skewness  Compute sample skewness of specified fields
  kurtosis  Compute sample kurtosis of specified fields
  min       Compute minimum values of specified fields
  max       Compute maximum values of specified fields
-f {a,b,c}  Value-field names on which to compute statistics. Requires -o.
-r {a,b,c}  Regular expressions for value-field names on which to compute
            statistics. Requires -o.
-c {a,b,c}  Substrings for collapse mode. All fields which have the same names
            after removing substrings will be accumulated together. Please see
            examples below.
-o {name}   Output field basename for -f/-r.
-k          Keep the input fields which contributed to the output statistics;
            the default is to omit them.
-F          Computes integerable things (e.g. count) in floating point.
Example input data: "a_in_x=1,a_out_x=2,b_in_y=4,b_out_x=8".
Example: mlr merge-fields -a sum,count -f a_in_x,a_out_x -o foo
  produces "b_in_y=4,b_out_x=8,foo_sum=3,foo_count=2" since "a_in_x,a_out_x" are
  summed over.
Example: mlr merge-fields -a sum,count -r in_,out_ -o bar
  produces "bar_sum=15,bar_count=4" since all four fields are summed over.
Example: mlr merge-fields -a sum,count -c in_,out_
  produces "a_x_sum=3,a_x_count=2,b_y_sum=4,b_y_count=1,b_x_sum=8,b_x_count=1"
  since "a_in_x" and "a_out_x" both collapse to "a_x", "b_in_y" collapses to
  "b_y", and "b_out_x" collapses to "b_x".
</pre>
</div>
<p/>

<p/>This is like <tt>mlr stats1</tt> but all accumulation is done across fields
within each given record: horizontal rather than vertical statistics, if you
will.

<p/>Examples:

<p/>
<div class="pokipanel">
<pre>
$ mlr --csvlite --opprint cat data/inout.csv
a_in a_out b_in b_out
436  490   446  195
526  320   963  780
220  888   705  831
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr --csvlite --opprint merge-fields -a min,max,sum -c _in,_out data/inout.csv
a_min a_max a_sum b_min b_max b_sum
436   490   926   195   446   641
320   526   846   780   963   1743
220   888   1108  705   831   1536
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr --csvlite --opprint merge-fields -k -a sum -c _in,_out data/inout.csv
a_in a_out b_in b_out a_sum b_sum
436  490   446  195   926   641
526  320   963  780   846   1743
220  888   705  831   1108  1536
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="put"/><h2>put</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr put --help
Usage: mlr put [options] {expression}
Adds/updates specified field(s). Expressions are semicolon-separated and must
either be assignments, or evaluate to boolean.  Each expression is evaluated in
turn from left to right. Assignment expressions are applied to the current
record; once a boolean expression evaluates to false, the record is emitted
with all changes up to that point and remaining expressions to the right are
not evaluated.

Options:
-v: First prints the AST (abstract syntax tree) for the expression, which gives
    full transparency on the precedence and associativity rules of Miller's
    grammar.
-S: Keeps field values, or literals in the expression, as strings with no type
    inference to int or float.
-F: Keeps field values, or literals in the expression, as strings or floats
    with no inference to int.

Please use a dollar sign for field names and double-quotes for string
literals. If field names have special characters such as "." then you might
use braces, e.g. '${field.name}'. Miller built-in variables are
NF NR FNR FILENUM FILENAME PI E.

Examples:
  Assignment only:
  mlr put '$y = log10($x); $z = sqrt($y)'
  mlr put '$filename = FILENAME'
  mlr put '$colored_shape = $color . "_" . $shape'
  mlr put '$y = cos($theta); $z = atan2($y, $x)'
  mlr put '$name = sub($name, "http.*com"i, "")'
  Mixed assignment/boolean:
  mlr put '$x &gt; 0.0; $y = log10($x); $z = sqrt($y)'
  mlr put '$y = log10($x); 1.1 &lt; $y &amp;&amp; $y &lt; 7.0; $z = sqrt($y)'

Please see http://johnkerl.org/miller/doc/reference.html for more information
including function list. Or "mlr -f".
</pre>
</div>
<p/>

<a id="Field_names_for_put"/><h3>Field names for put</h3>

<p/>Field names must be specified using a <tt>$</tt> in <a
href="#filter"><tt>filter</tt></a> and <tt>put</tt> expressions, even though
they don&rsquo;t appear in the data stream. For integer-indexed data, this
looks like <tt>awk</tt>&rsquo;s <tt>$1,$2,$3</tt>.  Likewise, enclose string
literals in double quotes in <tt>put</tt> expressions even though they
don&rsquo;t appear in file data. In particular, <tt>mlr put '$x="abc"'</tt>
creates the field <tt>x=abc</tt> and <tt>mlr filter '$x=="abc"'</tt> passes
through the field <tt>x</tt> if it has the value <tt>abc</tt>.  If field names
have special characters such as <tt>.</tt> then you can use braces, e.g.
<tt>'${field.name}'</tt>.

<a id="Built-in_variables_for_put"/><h3>Built-in variables for put</h3>

<p/>Miller supports the following five built-in variables for <a
href="#filter"><tt>filter</tt></a> and <tt>put</tt>, all <tt>awk</tt>-inspired:
<tt>NF</tt>, <tt>NR</tt>, <tt>FNR</tt>, <tt>FILENUM</tt>, and
<tt>FILENAME</tt>, as well as the mathematical constants <tt>PI</tt> and
<tt>E</tt>.

<a id="Expression_formatting_for_put"/><h3>Expression formatting for put</h3>

<p/>Multiple expressions may be given, separated by semicolons, and each may refer to the ones before:

<p/>
<div class="pokipanel">
<pre>
$ ruby -e '10.times{|i|puts "i=#{i}"}' | mlr --opprint put '$j = $i + 1; $k = $i +$j'
i j  k
0 1  1
1 2  3
2 3  5
3 4  7
4 5  9
5 6  11
6 7  13
7 8  15
8 9  17
9 10 19
</pre>
</div>
<p/>

<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint put '$nf=NF; $nr=NR; $fnr=FNR; $filenum=FILENUM; $filename=FILENAME' data/small data/small2
a   b   i     x                    y                    nf nr fnr filenum filename
pan pan 1     0.3467901443380824   0.7268028627434533   5  1  1   1       data/small
eks pan 2     0.7586799647899636   0.5221511083334797   5  2  2   1       data/small
wye wye 3     0.20460330576630303  0.33831852551664776  5  3  3   1       data/small
eks wye 4     0.38139939387114097  0.13418874328430463  5  4  4   1       data/small
wye pan 5     0.5732889198020006   0.8636244699032729   5  5  5   1       data/small
pan eks 9999  0.267481232652199086 0.557077185510228001 5  6  1   2       data/small2
wye eks 10000 0.734806020620654365 0.884788571337605134 5  7  2   2       data/small2
pan wye 10001 0.870530722602517626 0.009854780514656930 5  8  3   2       data/small2
hat wye 10002 0.321507044286237609 0.568893318795083758 5  9  4   2       data/small2
pan zee 10003 0.272054845593895200 0.425789896597056627 5  10 5   2       data/small2
</pre>
</div>
<p/>

Newlines within the expression are ignored, which can help increase legibility of complex expressions:

<p/>
<div class="pokipanel">
<pre>
mlr --opprint put '
  $nf       = NF;
  $nr       = NR;
  $fnr      = FNR;
  $filenum  = FILENUM;
  $filename = FILENAME' \
  data/small data/small2

</pre>
</div>
<p/>

<a id="Gating_assignments_by_boolean_expressions_for_put"/><h3>Gating assignments by boolean expressions for put</h3>

<p/>Boolean expressions may be used as gates for subsequent semicolon-separated
expressions within the same <tt>put</tt>. This can be used to allow assignments
to be done only when appropriate &mdash; e.g. for math-function domain
restrictions, regex-matching, and so on:

<p/>
<div class="pokipanel">
<pre>
$ mlr cat data/put-gating-example-1.dkvp
x=-1
x=0
x=1
x=2
x=3
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr put 'gate $x &gt; 0.0; $y = log10($x); $z = sqrt($y)' data/put-gating-example-1.dkvp
x=-1
x=0
x=1,y=0.000000,z=0.000000
x=2,y=0.301030,z=0.548662
x=3,y=0.477121,z=0.690740
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr cat data/put-gating-example-2.dkvp
a=abc_123
a=some other name
a=xyz_789
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr put 'gate $a =~ "([a-z]+)_([0-9]+)"; $b = "left_\1"; $c = "right_\2"' data/put-gating-example-2.dkvp
a=abc_123,b=left_abc,c=right_123
a=some other name
a=xyz_789,b=left_xyz,c=right_789
</pre>
</div>
<p/>

<p/>This produces heteregenous output which Miller, of course, has no problems
with (see <a href="record-heterogeneity.html">Record-heterogeneity</a>).  But
if homogeneous output is desired, the <tt>gate</tt> can be omitted.  This
causes <tt>put</tt> to evaluate the boolean expression (along with any side
effects, namely, regex-captures <tt>\1</tt>, <tt>\2</tt>, etc.) but
doesn&rsquo;t use it as a criterion for whether subsequent assignments should
be executed. Instead, subsequent assignments are done unconditionally:

<p/>
<div class="pokipanel">
<pre>
$ mlr put '$x &gt; 0.0; $y = log10($x); $z = sqrt($y)' data/put-gating-example-1.dkvp
x=-1,y=nan,z=nan
x=0,y=-inf,z=nan
x=1,y=0.000000,z=0.000000
x=2,y=0.301030,z=0.548662
x=3,y=0.477121,z=0.690740
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr put '$a =~ "([a-z]+)_([0-9]+)"; $b = "left_\1"; $c = "right_\2"' data/put-gating-example-2.dkvp
a=abc_123,b=left_abc,c=right_123
a=some other name,b=left_,c=right_
a=xyz_789,b=left_xyz,c=right_789
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="regularize"/><h2>regularize</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr regularize --help
Usage: mlr regularize
For records seen earlier in the data stream with same field names in
a different order, outputs them with field names in the previously
encountered order.
Example: input records a=1,c=2,b=3, then e=4,d=5, then c=7,a=6,b=8
output as              a=1,c=2,b=3, then e=4,d=5, then a=6,c=7,b=8
</pre>
</div>
<p/>

<p/>This exists since hash-map software in various languages and tools
encountered in the wild does not always print similar rows with fields in the
same order: <tt>mlr regularize</tt> helps clean that up.

<p/>See also <a href="#reorder"><tt>reorder</tt></a>.

<!-- ================================================================ -->
<a id="rename"/><h2>rename</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr rename --help
Usage: mlr rename [options] {old1,new1,old2,new2,...}
Renames specified fields.
Options:
-r         Treat old field  names as regular expressions. "ab", "a.*b"
           will match any field name containing the substring "ab" or
           matching "a.*b", respectively; anchors of the form "^ab$",
           "^a.*b$" may be used. New field names may be plain strings,
           or may contain capture groups of the form "\1" through
           "\9". Wrapping the regex in double quotes is optional, but
           is required if you wish to follow it with 'i' to indicate
           case-insensitivity.
-g         Do global replacement within each field name rather than
           first-match replacement.
Examples:
mlr rename -f old_name,new_name'
mlr rename -f old_name_1,new_name_1,old_name_2,new_name_2'
mlr rename -r 'Date_[0-9]+,Date,'  Rename all such fields to be "Date"
mlr rename -r '"Date_[0-9]+",Date' Same
mlr rename -r 'Date_([0-9]+).*,\1' Rename all such fields to be of the form 20151015
mlr rename -r '"name"i,Name'       Rename "name", "Name", "NAME", etc. to "Name"
</pre>
</div>
<p/>

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint cat data/small
a   b   i x                   y
pan pan 1 0.3467901443380824  0.7268028627434533
eks pan 2 0.7586799647899636  0.5221511083334797
wye wye 3 0.20460330576630303 0.33831852551664776
eks wye 4 0.38139939387114097 0.13418874328430463
wye pan 5 0.5732889198020006  0.8636244699032729
</pre>
</div>
<p/>
</td><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint rename i,INDEX,b,COLUMN2 data/small
a   COLUMN2 INDEX x                   y
pan pan     1     0.3467901443380824  0.7268028627434533
eks pan     2     0.7586799647899636  0.5221511083334797
wye wye     3     0.20460330576630303 0.33831852551664776
eks wye     4     0.38139939387114097 0.13418874328430463
wye pan     5     0.5732889198020006  0.8636244699032729
</pre>
</div>
<p/>
</td></tr></table>

<p/>As discussed in <a href="performance.html">Performance</a>, <tt>sed</tt>
is significantly faster than Miller at doing this. However, Miller is
format-aware, so it knows to do renames only within specified field keys and
not any others, nor in field values which may happen to contain the same
pattern. Example:

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ sed 's/y/COLUMN5/g' data/small
a=pan,b=pan,i=1,x=0.3467901443380824,COLUMN5=0.7268028627434533
a=eks,b=pan,i=2,x=0.7586799647899636,COLUMN5=0.5221511083334797
a=wCOLUMN5e,b=wCOLUMN5e,i=3,x=0.20460330576630303,COLUMN5=0.33831852551664776
a=eks,b=wCOLUMN5e,i=4,x=0.38139939387114097,COLUMN5=0.13418874328430463
a=wCOLUMN5e,b=pan,i=5,x=0.5732889198020006,COLUMN5=0.8636244699032729
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr rename y,COLUMN5 data/small
a=pan,b=pan,i=1,x=0.3467901443380824,COLUMN5=0.7268028627434533
a=eks,b=pan,i=2,x=0.7586799647899636,COLUMN5=0.5221511083334797
a=wye,b=wye,i=3,x=0.20460330576630303,COLUMN5=0.33831852551664776
a=eks,b=wye,i=4,x=0.38139939387114097,COLUMN5=0.13418874328430463
a=wye,b=pan,i=5,x=0.5732889198020006,COLUMN5=0.8636244699032729
</pre>
</div>
<p/>
</td></tr></table>

See also <a href="#label"><tt>label</tt></a>.

<!-- ================================================================ -->
<a id="reorder"/><h2>reorder</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr reorder --help
Usage: mlr reorder [options]
-f {a,b,c}   Field names to reorder.
-e           Put specified field names at record end: default is to put
             them at record start.
Examples:
mlr reorder    -f a,b sends input record "d=4,b=2,a=1,c=3" to "a=1,b=2,d=4,c=3".
mlr reorder -e -f a,b sends input record "d=4,b=2,a=1,c=3" to "d=4,c=3,a=1,b=2".
</pre>
</div>
<p/>

This pivots specified field names to the start or end of the record &mdash; for
example when you have highly multi-column data and you want to bring a field or
two to the front of line where you can give a quick visual scan.

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint cat data/small
a   b   i x                   y
pan pan 1 0.3467901443380824  0.7268028627434533
eks pan 2 0.7586799647899636  0.5221511083334797
wye wye 3 0.20460330576630303 0.33831852551664776
eks wye 4 0.38139939387114097 0.13418874328430463
wye pan 5 0.5732889198020006  0.8636244699032729
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint reorder -f i,b data/small
i b   a   x                   y
1 pan pan 0.3467901443380824  0.7268028627434533
2 pan eks 0.7586799647899636  0.5221511083334797
3 wye wye 0.20460330576630303 0.33831852551664776
4 wye eks 0.38139939387114097 0.13418874328430463
5 pan wye 0.5732889198020006  0.8636244699032729
</pre>
</div>
<p/>
</td><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint reorder -e -f i,b data/small
a   x                   y                   i b
pan 0.3467901443380824  0.7268028627434533  1 pan
eks 0.7586799647899636  0.5221511083334797  2 pan
wye 0.20460330576630303 0.33831852551664776 3 wye
eks 0.38139939387114097 0.13418874328430463 4 wye
wye 0.5732889198020006  0.8636244699032729  5 pan
</pre>
</div>
<p/>
</td></tr></table>

<!-- ================================================================ -->
<a id="reshape"/><h2>reshape</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr reshape --help
Usage: mlr reshape [options]
Wide-to-long options:
  -i {input field names}   -o {key-field name,value-field name}
  -r {input field regexes} -o {key-field name,value-field name}
  These pivot/reshape the input data such that the input fields are removed
  and separate records are emitted for each key/value pair.
  Note: this works with tail -f and produces output records for each input
  record seen.
Long-to-wide options:
  -s {key-field name,value-field name}
  These pivot/reshape the input data to undo the wide-to-long operation.
  Note: this does not work with tail -f; it produces output records only after
  all input records have been read.

Examples:

  Input file "wide.txt":
    time       X           Y
    2009-01-01 0.65473572  2.4520609
    2009-01-02 -0.89248112 0.2154713
    2009-01-03 0.98012375  1.3179287

  mlr --pprint reshape -i X,Y -o item,value wide.txt
    time       item value
    2009-01-01 X    0.65473572
    2009-01-01 Y    2.4520609
    2009-01-02 X    -0.89248112
    2009-01-02 Y    0.2154713
    2009-01-03 X    0.98012375
    2009-01-03 Y    1.3179287

  mlr --pprint reshape -r '[A-Z]' -o item,value wide.txt
    time       item value
    2009-01-01 X    0.65473572
    2009-01-01 Y    2.4520609
    2009-01-02 X    -0.89248112
    2009-01-02 Y    0.2154713
    2009-01-03 X    0.98012375
    2009-01-03 Y    1.3179287

  Input file "long.txt":
    time       item value
    2009-01-01 X    0.65473572
    2009-01-01 Y    2.4520609
    2009-01-02 X    -0.89248112
    2009-01-02 Y    0.2154713
    2009-01-03 X    0.98012375
    2009-01-03 Y    1.3179287

  mlr --pprint reshape -s item,value long.txt
    time       X           Y
    2009-01-01 0.65473572  2.4520609
    2009-01-02 -0.89248112 0.2154713
    2009-01-03 0.98012375  1.3179287
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="sample"/><h2>sample</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr sample --help
Usage: mlr sample [options]
Reservoir sampling (subsampling without replacement), optionally by category.
-k {count}    Required: number of records to output, total, or by group if using -g.
-g {a,b,c}    Optional: group-by-field names for samples.
</pre>
</div>
<p/>

<p/>This is reservoir-sampling: select <i>k</i> items from <i>n</i> with
uniform probability and no repeats in the sample. (If <i>n</i> is less than
<i>k</i>, then of course only <i>n</i> samples are produced.) With <tt>-g
{field names}</tt>, produce a <i>k</i>-sample for each distinct value of the
specified field names.

<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint sample -k 4 data/colored-shapes.dkvp
color  shape    flag i     u                   v                    w                   x
purple triangle 0    90122 0.9986871176198068  0.3037738877233719   0.5154934457238382  5.365962021016529
red    circle   0    3139  0.04835898233323954 -0.03964684310055758 0.5263660881848111  5.3758779366493625
orange triangle 0    67847 0.36746306902109926 0.5161574810505635   0.5176199566173642  3.1748088656576567
yellow square   1    33576 0.3098376725521097  0.8525628505287842   0.49774122460981685 4.494754378604669

$ mlr --opprint sample -k 4 data/colored-shapes.dkvp
color  shape  flag i     u                     v                   w                   x
blue   square 1    16783 0.09974385090654347   0.7243899920872646  0.5353718443278438  4.431057737383438
orange square 1    93291 0.5944176543007182    0.17744449786454086 0.49262281749172077 3.1548117990710653
yellow square 1    54436 0.5268161165014636    0.8785588662666121  0.5058773791931063  7.019185838783636
yellow square 1    55491 0.0025440267883102274 0.05474106287787284 0.5102729153751984  3.526301273728043

$ mlr --opprint sample -k 2 -g color data/colored-shapes.dkvp
color  shape    flag i     u                    v                   w                    x
yellow triangle 1    11    0.6321695890307647   0.9887207810889004  0.4364983936735774   5.7981881667050565
yellow square   1    917   0.8547010348386344   0.7356782810796262  0.4531511689924275   5.774541777078352
red    circle   1    4000  0.05490416175132373  0.07392337815122155 0.49416101516594396  5.355725080701707
red    square   0    87506 0.6357719216821314   0.6970867759393995  0.4940826462055272   6.351579417310387
purple triangle 0    14898 0.7800986870203719   0.23998073813992293 0.5014775988383656   3.141006771777843
purple triangle 0    151   0.032614487569017414 0.7346633365041219  0.7812143304483805   2.6831992610568047
green  triangle 1    126   0.1513010528347546   0.40346767294704544 0.051213231883952326 5.955109300797182
green  circle   0    17635 0.029856606049114442 0.4724542934246524  0.49529606749929744  5.239153910272168
blue   circle   1    1020  0.414263129226617    0.8304946402876182  0.13151094520189244  4.397873687920433
blue   triangle 0    220   0.441773289968473    0.44597731903759075 0.6329360666849821   4.3064608776550894
orange square   0    1885  0.8079311983747106   0.8685956833908394  0.3116410800256374   4.390864584500387
orange triangle 0    1533  0.32904497195507487  0.23168161807490417 0.8722623057355134   5.164071635714438

$ mlr --opprint sample -k 2 -g color then sort -f color data/colored-shapes.dkvp
color  shape    flag i     u                   v                    w                   x
blue   circle   0    215   0.7803586969333292  0.33146680638888126  0.04289047852629113 5.725365736377487
blue   circle   1    3616  0.8548431579124808  0.4989623130006362   0.3339426415875795  3.696785877560498
green  square   0    356   0.7674272008085286  0.341578843118008    0.4570224877870851  4.830320062215299
green  square   0    152   0.6684429446914862  0.016056003736548696 0.4656148241291592  5.434588759225423
orange triangle 0    587   0.5175826237797857  0.08989091493635304  0.9011709461770973  4.265854207755811
orange triangle 0    1533  0.32904497195507487 0.23168161807490417  0.8722623057355134  5.164071635714438
purple triangle 0    14192 0.5196327866973567  0.7860928603468063   0.4964368415453642  4.899167143824484
purple triangle 0    65    0.6842806710360729  0.5823723856331258   0.8014053396013747  5.805148213865135
red    square   1    2431  0.38378504852300466 0.11445015005595527  0.49355539228753786 5.146756570128739
red    triangle 0    57097 0.43763430414406546 0.3355450325004481   0.5322349637512487  4.144267240289442
yellow triangle 1    11    0.6321695890307647  0.9887207810889004   0.4364983936735774  5.7981881667050565
yellow square   1    158   0.41527900739142165 0.7118027080775757   0.4200799665161291  5.33279067554884

</pre>
</div>
<p/>

<p/>Note that no output is produced until all inputs are in. Another way to do
sampling, which works in the streaming case, is <tt>mlr filter 'urand() &amp;
0.001'</tt> where you tune the 0.001 to meet your needs.

<!-- ================================================================ -->
<a id="sec2gmt"/><h2>sec2gmt</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr sec2gmt -h
Usage: mlr sec2gmt {comma-separated list of field names}
Replaces a numeric field representing seconds since the epoch with the
corresponding GMT timestamp. This is nothing more than a keystroke-saver for
the sec2gmt function:
  mlr sec2gmt time1,time2
is the same as
  mlr put '$time1=sec2gmt($time1);$time2=sec2gmt($time2)'
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="sort"/><h2>sort</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr sort --help
Usage: mlr sort {flags}
Flags:
  -f  {comma-separated field names}  Lexical ascending
  -n  {comma-separated field names}  Numerical ascending; nulls sort last
  -nf {comma-separated field names}  Numerical ascending; nulls sort last
  -r  {comma-separated field names}  Lexical descending
  -nr {comma-separated field names}  Numerical descending; nulls sort first
Sorts records primarily by the first specified field, secondarily by the second
field, and so on.  Any records not having all specified sort keys will appear
at the end of the output, in the order they were encountered, regardless of the
specified sort order.
Example:
  mlr sort -f a,b -nr x,y,z
which is the same as:
  mlr sort -f a -f b -nr x -nr y -nr z
</pre>
</div>
<p/>

<p/>Example:
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint sort -f a -nr x data/small
a   b   i x                   y
eks pan 2 0.7586799647899636  0.5221511083334797
eks wye 4 0.38139939387114097 0.13418874328430463
pan pan 1 0.3467901443380824  0.7268028627434533
wye pan 5 0.5732889198020006  0.8636244699032729
wye wye 3 0.20460330576630303 0.33831852551664776
</pre>
</div>
<p/>

<p/>Here&rsquo;s an example filtering log data: suppose multiple threads (labeled here by color) are all logging progress counts to a single log file. The log file is (by nature) chronological, so the progress of various threads is interleaved:

<p/>
<div class="pokipanel">
<pre>
$ head -n 10 data/multicountdown.dat
upsec=0.002,color=green,count=1203
upsec=0.083,color=red,count=3817
upsec=0.188,color=red,count=3801
upsec=0.395,color=blue,count=2697
upsec=0.526,color=purple,count=953
upsec=0.671,color=blue,count=2684
upsec=0.899,color=purple,count=926
upsec=0.912,color=red,count=3798
upsec=1.093,color=blue,count=2662
upsec=1.327,color=purple,count=917
</pre>
</div>
<p/>

<p/> We can group these by thread by sorting on the thread ID (here,
<tt>color</tt>). Since Miller&rsquo;s sort is stable, this means that
timestamps within each thread&rsquo;s log data are still chronological:

<p/>
<div class="pokipanel">
<pre>
$ head -n 20 data/multicountdown.dat | mlr --opprint sort -f color
upsec              color  count
0.395              blue   2697
0.671              blue   2684
1.093              blue   2662
2.064              blue   2659
2.2880000000000003 blue   2647
0.002              green  1203
1.407              green  1187
1.448              green  1177
2.313              green  1161
0.526              purple 953
0.899              purple 926
1.327              purple 917
1.703              purple 908
0.083              red    3817
0.188              red    3801
0.912              red    3798
1.416              red    3788
1.587              red    3782
1.601              red    3755
1.832              red    3717
</pre>
</div>
<p/>

<p/>Any records not having all specified sort keys will appear at the end of the output, in the order they
were encountered, regardless of the specified sort order:

<p/>
<div class="pokipanel">
<pre>
$ mlr sort -n  x data/sort-missing.dkvp
x=1
x=2
x=4
a=3
</pre>
</div>
<p/>
<p/>
<div class="pokipanel">
<pre>
$ mlr sort -nr x data/sort-missing.dkvp
x=4
x=2
x=1
a=3
</pre>
</div>
<p/>

<!-- ================================================================ -->
<a id="stats1"/><h2>stats1</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr stats1 --help
Usage: mlr stats1 [options]
Computes univariate statistics for one or more given fields, accumulated across
the input record stream.
Options:
-a {sum,count,...}  Names of accumulators: p10 p25.2 p50 p98 p100 etc. and/or
                    one or more of:
  count     Count instances of fields
  mode      Find most-frequently-occurring values for fields; first-found wins tie
  sum       Compute sums of specified fields
  mean      Compute averages (sample means) of specified fields
  stddev    Compute sample standard deviation of specified fields
  var       Compute sample variance of specified fields
  meaneb    Estimate error bars for averages (assuming no sample autocorrelation)
  skewness  Compute sample skewness of specified fields
  kurtosis  Compute sample kurtosis of specified fields
  min       Compute minimum values of specified fields
  max       Compute maximum values of specified fields
-f {a,b,c}  Value-field names on which to compute statistics
-g {d,e,f}  Optional group-by-field names
-s          Print iterative stats. Useful in tail -f contexts (in which
            case please avoid pprint-format output since end of input
            stream will never be seen).
-F          Computes integerable things (e.g. count) in floating point.
Example: mlr stats1 -a min,p10,p50,p90,max -f value -g size,shape
Example: mlr stats1 -a count,mode -f size
Example: mlr stats1 -a count,mode -f size -g shape
Notes:
* p50 is a synonym for median.
* min and max output the same results as p0 and p100, respectively, but use
  less memory.
* count and mode allow text input; the rest require numeric input.
  In particular, 1 and 1.0 are distinct text for count and mode.
* When there are mode ties, the first-encountered datum wins.
</pre>
</div>
<p/>

These are simple univariate statistics on one or more number-valued fields
(<tt>count</tt> and <tt>mode</tt> apply to non-numeric fields as well),
optionally categorized by one or more other fields.

<table><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --oxtab stats1 -a count,sum,min,p10,p50,mean,p90,max -f x,y data/medium
x_count 10000
x_sum   4986.019682
x_min   0.000045
x_p10   0.093322
x_p50   0.501159
x_mean  0.498602
x_p90   0.900794
x_max   0.999953
y_count 10000
y_sum   5062.057445
y_min   0.000088
y_p10   0.102132
y_p50   0.506021
y_mean  0.506206
y_p90   0.905366
y_max   0.999965
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint stats1 -a mean -f x,y -g b then sort -f b data/medium
b   x_mean   y_mean
eks 0.506361 0.510293
hat 0.487899 0.513118
pan 0.497304 0.499599
wye 0.497593 0.504596
zee 0.504242 0.502997
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint stats1 -a p50,p99 -f u,v -g color then put '$ur=$u_p99/$u_p50;$vr=$v_p99/$v_p50' data/colored-shapes.dkvp
color  u_p50    u_p99    v_p50    v_p99    ur       vr
yellow 0.501019 0.989046 0.520630 0.987034 1.974069 1.895845
red    0.485038 0.990054 0.492586 0.994444 2.041189 2.018823
purple 0.501319 0.988893 0.504571 0.988287 1.972582 1.958668
green  0.502015 0.990764 0.505359 0.990175 1.973574 1.959350
blue   0.525226 0.992655 0.485170 0.993873 1.889958 2.048505
orange 0.483548 0.993635 0.480913 0.989102 2.054884 2.056717
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint count-distinct -f shape then sort -nr count data/colored-shapes.dkvp
shape    count
square   4115
triangle 3372
circle   2591
</pre>
</div>
<p/>
</td></tr><tr><td>
<p/>
<div class="pokipanel">
<pre>
$ mlr --opprint stats1 -a mode -f color -g shape data/colored-shapes.dkvp
shape    color_mode
triangle red
square   red
circle   red
</pre>
</div>
<p/>
</td></tr></table>

<!-- ================================================================ -->
<a id="stats2"/><h2>stats2</h2>

<p/>
<div class="pokipanel">
<pre>
$ mlr stats2 --help
Usage: mlr stats2 [options]
Computes bivariate statistics for one or more given field-name pairs,